<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>lab4-2 Wireshark-80211</title>
      <link href="/2022/12/29/CNLab4-2/"/>
      <url>/2022/12/29/CNLab4-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Lab4-2-802-11"><a href="#Lab4-2-802-11" class="headerlink" title="Lab4-2 802.11"></a>Lab4-2 802.11</h2><h4 id="1-Objective"><a href="#1-Objective" class="headerlink" title="1 Objective"></a>1 Objective</h4><p>探究802.11的物理层、链路层和管理功能。</p><h4 id="2-Requirements"><a href="#2-Requirements" class="headerlink" title="2 Requirements"></a>2 Requirements</h4><p>Wireshark软件。</p><h4 id="3-Steps"><a href="#3-Steps" class="headerlink" title="3 Steps"></a>3 Steps</h4><h5 id="Step-1-Fetch-a-Trace"><a href="#Step-1-Fetch-a-Trace" class="headerlink" title="Step 1: Fetch a Trace"></a>Step 1: Fetch a Trace</h5><p>直接打开附件里的”trace-80211.pcap”来进行探究。</p><p><img src="image-20221130225233978.png" alt="image-20221130225233978"></p><h5 id="Step-2-Inspect-the-Trace"><a href="#Step-2-Inspect-the-Trace" class="headerlink" title="Step 2: Inspect the Trace"></a>Step 2: Inspect the Trace</h5><p>首先，我们将研究802.11帧的格式。如下图，有许多不同种类的802.11帧被捕获在了追踪中，我们可以通过info字段来分辨他们的类型，如Beacon、Data和Acknowledgement。</p><p><img src="image-20221130225721909.png" alt="image-20221130225721909"></p><p>我们选中一个数据帧进行查看：</p><p><img src="image-20221130230045230.png" alt="image-20221130230045230"></p><ul><li><p>“Frame”是由Wireshark添加的记录，包含了帧的时间和长度信息等。</p><p><img src="image-20221130231545659.png" alt="image-20221130231545659"></p></li><li><p>“Radiotap”也是Wireshark添加的记录，用于捕获物理层参数，如信号的强度和调制。</p><p><img src="image-20221130231602103.png" alt="image-20221130231602103"></p></li><li><p>“IEEE 802.11”是802.11数据帧的位。</p><p><img src="image-20221130231613913.png" alt="image-20221130231613913"></p></li><li><p>“Data”是包含帧有效载荷数据的记录，即具有诸如LLC、IP包等更高层协议的数据。或者，可以看到更高层的协议本身。</p><p><img src="image-20221130231636337.png" alt="image-20221130231636337"></p></li></ul><p>接下来我们将重点探究”IEEE 802.11”中的内容。</p><ul><li><p>“Frame Control”编码帧的类型和子类型。</p><p><img src="image-20221130234650774.png" alt="image-20221130234650774"></p></li><li><p>“Duration”告诉计算机作为交换的一部分的附加数据包在无线媒体上需要多长时间。</p><p><img src="image-20221130234709140.png" alt="image-20221130234709140"></p></li><li><p>“Destination address”和”Source address”（顺序取决于数据帧的具体内容）这些地址字段标识了数据包的发送者和应接收者。</p><p><img src="image-20221130234849051.png" alt="image-20221130234849051"></p></li><li><p>“BSS Id”是无线接入点的地址。</p><p><img src="image-20221130234907719.png" alt="image-20221130234907719"></p></li><li><p>“Fragment number”和”Sequence number”这些字段为重组和重传的帧编号，序号随着每一次新的传输而递增。</p><p><img src="image-20221130234929032.png" alt="image-20221130234929032"></p></li><li><p>“Frame check sequence”是帧上的循环冗余校验码。</p><p><img src="image-20221130234939063.png" alt="image-20221130234939063"></p></li><li><p>在帧有效负载被加密的情况下，还可能有一个WEP或WPA2字段，其中包含安全参数。</p><p><img src="image-20221130234948154.png" alt="image-20221130234948154"></p></li></ul><p>最后，我们再重点探究一下”Frame Control”字段的详细内容。</p><p><img src="image-20221130235557521.png" alt="image-20221130235557521"></p><ul><li>“Version”是版本号，目前为0（三种类型的帧统一，均为0）。</li><li>“Type”和”Subtype”指定帧的类型。</li><li>“DS status”中包含了”To DS”和”From DS”的值：如果帧从计算机通过AP发送至有线网络，则将”To DS”置为1；如果帧从有线网络通过AP发送至计算机，则将”From DS”置为1。</li><li>“More Fragments”描述了消息中是否有更多的帧。</li><li>“Retry”描述了帧是否重传。</li><li>“PWR MGT”意为”Power management”，设置了发送方在传输后是否进入省电休眠状态。</li><li>“More Data”描述发送端是否有更多的帧要发送。</li><li>“Protected”描述了帧是否用WEP/WPA2加密。</li><li>“+HTC/Order”描述了接收端是否必须保持帧的顺序。</li></ul><h5 id="Step-3-802-11-Physical-Layer"><a href="#Step-3-802-11-Physical-Layer" class="headerlink" title="Step 3: 802.11 Physical Layer"></a>Step 3: 802.11 Physical Layer</h5><p>现在我们已经对802.11数据帧有了一些了解，接下来我们将从物理层开始研究无线系统的其他部分。在最低层，发送和接收消息都与接收信号的频带、调制、信噪比有关，我们可以在Radiotap中的信息查看所有这些元素。</p><p><em>Q: What is the channel frequency?</em></p><p><em>A：展开”Radiotap Header”，即可查看”Channel frequency”的值。</em></p><p><img src="image-20221201004342137.png" alt="image-20221201004342137"></p><p>要查看调制，我们可以观察数据速率值，要查看信噪比，我们可以观察SSI信号值，SSI信号值通常被称为RSSI(接收信号强度指示)。要查看这些字段，首先必须向主显示添加新列，步骤如下：</p><ol><li><p>按”编辑-首选项-外观-列“的顺序依次点击以进入列显示定义面板。</p></li><li><p>点击左下角”+”以添加新的显示列。</p></li><li><p>将”Title”修改为”RSSI”，类型选择”IEEE 802.11 RSSI”。</p></li><li><p>再添加一个新的显示列，将”Title”修改为”Rate”，类型选择”IEEE 802.11 TX rate”，然后选择”OK”完成添加。</p><p><img src="image-20221201005949990.png" alt="image-20221201005949990"></p></li></ol><p>我们返回主页面，可以看到”RSSI”列和”Rate”列已成功添加。</p><p><img src="image-20221201011138673.png" alt="image-20221201011138673"></p><p>在”Rate”列，我们可以看到各种各样的速率。也就是说，与有线以太网的帧以固定速率发送(经过以太网类型的协商)不同，无线速率根据计算机的条件和能力而变化。</p><p><em>Q: What rates are used? Give an ordered list of rates from lowest to highest.</em></p><p><em>A：点击”Rate”列，将帧按速率值从小到大的顺序进行排列，可以看到速率分别为1、6、12、18、24、38、48和54mbps，下面截取了部分速率区段。</em></p><p><img src="image-20221201012040044.png" alt="image-20221201012040044"></p><p><img src="image-20221201012115175.png" alt="image-20221201012115175"></p><p><img src="image-20221201012021756.png" alt="image-20221201012021756"></p><p>在”RSSI”列，我们可以看到各种各样的RSSI值，如“-60 dBm”。RSSI是在对数刻度上测量的，其中0 dBm表示1兆瓦的功率，每+10表示大10倍，每-10表示小10倍。因此-60 dBm意味着 $10^{-9}$ 瓦，即1兆瓦的百万分之一，是非常小的功率。</p><p>信噪比是相对于噪声水平的信号水平，如下图中，信号水平为-60 dBm，噪声水平为-90 dBm，这意味着信号水平比噪声水平大1000倍，那么信噪比就为30 dB。</p><p><img src="image-20221201013239069.png" alt="image-20221201013239069"></p><p><em>Q: What is the range of RSSI and hence variation in SNRs in the trace? Give this as the strongest and  weakest RSSI and the dB difference between them.</em></p><p><em>A：点击”RSSI”列，将帧按RSSI值从小到大的顺序进行排列，可以看到RSSI的变化范围为-44 dBm（最强信号）到-69 dBm（最弱信号），中间相差了25分贝，前后信噪比之比约为316（$10^{2.5}≈316$）。</em></p><p><img src="image-20221201014512601.png" alt="image-20221201014512601"></p><p><img src="image-20221201014524273.png" alt="image-20221201014524273"></p><h5 id="Step-4-802-11-Link-Layer"><a href="#Step-4-802-11-Link-Layer" class="headerlink" title="Step 4: 802.11 Link Layer"></a>Step 4: 802.11 Link Layer</h5><p>在”统计”菜单下，选择”会话”，然后勾选”IEEE 802.11”。</p><p><img src="image-20221201214202951.png" alt="image-20221201214202951"></p><p>转到”IEEE 802.11”栏，我们将看到如下图所示的窗口，其中列出了每对正在通信的计算机。</p><p><img src="image-20221201214411420.png" alt="image-20221201214411420"></p><p>大部分的活动都是在相对较小的部分对话中。低活动会话是由于来自空闲计算机的后台流量，以及偶尔从相邻无线网络捕获的少量包。BSS ID值标识一个AP。</p><p><em>Q: What is the BSS ID used by the most active wireless conversations? A BSS ID value identifies an  AP, so this BSS ID identifies the most active AP, presumably the AP we are monitoring.</em> </p><p><em>A：为了找到最活跃的无线会话使用的BSS ID，我们可以通过单击列标题对信息进行排序，可以发现，最活跃的AP的BSS ID是00:16:b6:e3:e9:8f。</em></p><p><img src="image-20221201215503765.png" alt="image-20221201215503765"></p><p>我们可以在”应用显示过滤器”处输入表达式”wlan.fc.type\==”data frame””或”wlan.fc.type\==2”来只查看数据帧。</p><p><img src="image-20221201220113563.png" alt="image-20221201220113563"></p><p><em>Q: How many Data frames are in the trace, and what is the most common subtype of Data frame?</em></p><p><em>A：我们可以从右下角看到当前显示帧的总数为1783，而当前显示的帧正是我们筛选得到的数据帧，所以数据帧的总数为1783。依次查看各帧的详细信息可以发现，数据帧最常见的子类型是”Data”。</em></p><p><img src="image-20221201221004626.png" alt="image-20221201221004626"></p><p>通过更改筛选表达式来对Control (Type 1)和Management (Type 0)帧执行相同的操作。</p><p><em>Q: How many Control frames are in the trace, and what is the most common subtype?</em> </p><p><em>A：用跟之前同样的方法，我们可以得到控制帧的总数为1391。依次查看各帧的详细信息可以发现，控制帧最常见的子类型是”Acknowledgement”。</em></p><p><img src="image-20221201221930338.png" alt="image-20221201221930338"></p><p><em>Q: How many Management frames are in the trace, and what is the most common subtype?</em></p><p><em>A：同理，我们也可以得到管理帧的总数为557。依次查看各帧的详细信息可以发现，管理帧最常见的子类型是”Beacon frame”。</em></p><p><img src="image-20221201222144297.png" alt="image-20221201222144297"></p><p><em>Q: List in the order they are sent the IEEE 802.11 fields in an Acknowledgement frame and their  lengths in bytes. Do not break down the Frame Control field into subfields, as we have already  looked at these details.</em></p><p><em>A：如果我们检查一个”Acknowledgement”帧的IEEE 802.11记录，我们应该看到它与数据帧相比字段很少，例如，只有一个地址，而且它非常短。这些字段分别是帧控制(2个字节)、持续时间(2个字节)、接收地址(6个字节)和帧检查序列(4个字节)。</em></p><p><img src="image-20221201222740747.png" alt="image-20221201222740747"></p><p>无线传输不像有线传输那样高度可靠，但无线误差率不会很大，否则会浪费大量的介质。我们可以通过估计重传率或检查有多少帧的重试位设置在了帧控制字段（这个位表示一个帧是原始帧的重传）来估算无线误差率。</p><p>我们可以通过使用过滤器表达式来查找原始数据帧和重传数据帧的数量。例如，“wlan.fc.type \==2 &amp;&amp; wlan.fc.retry==0”将找到原始数据帧。</p><p><em>Q: Give an estimate of the retransmission rate as the number of retransmissions over the number of  original transmissions. Show your calculation.</em></p><p><em>A：在应用显示过滤器处输入“wlan.fc.type \==2 &amp;&amp; wlan.fc.retry==0”来筛选原始数据帧，可以发现其个数为1430；输入“wlan.fc.type \==2 &amp;&amp; wlan.fc.retry\==1”来筛选重传数据帧，可以发现其个数为353。由此可以估计重传率为24.69%（353/1430≈0.24685）。</em></p><p><img src="image-20221201223909438.png" alt="image-20221201223909438"></p><p><img src="image-20221201223955873.png" alt="image-20221201223955873"></p><p>最后，我们将研究电源管理。越来越多的802.11客户端设备在完成发送或接收流量时使用电源管理功能进入低功耗休眠模式。准备休眠的客户端会在帧控制字段中设置电源管理标志，我们可以使用过滤器表达式”wlan.fc.pwrmgt\==1”来搜索表明客户端将要休眠的帧。我们只需要考虑从客户端到AP的帧的省电行为，因为来自AP的帧并不表示客户端将进入睡眠状态，这些帧将有”to DS”标志设置(“wlan.fc.tods==1”)。要搜索这两个条件，可以使用“&amp;&amp;”或“and”组合筛选器表达式。</p><p><em>Q: What fraction of the frames sent to the AP signal that the client is powering down?</em></p><p><em>A：依次用”wlan.fc.tods\==1”和”wlan.fc.pwrmgt\==1 and wlan.fc.tods==1”筛选后可以发现，发送到AP的帧共822个，其中有16帧设置了电源管理标志，比例约为1.95％(16/822≈0.01946)。</em></p><p><img src="image-20221201225156607.png" alt="image-20221201225156607"></p><p><img src="image-20221201224940792.png" alt="image-20221201224940792"></p><h5 id="Step-5-802-11-Management"><a href="#Step-5-802-11-Management" class="headerlink" title="Step 5: 802.11 Management"></a>Step 5: 802.11 Management</h5><p>接下来，我们将研究几种类型的管理帧。</p><h6 id="Beacon-Frames"><a href="#Beacon-Frames" class="headerlink" title="Beacon Frames"></a>Beacon Frames</h6><p>选择BSS ID为Step 4中的主AP的”Beacon Frame”。我们将看到，在一些固定的参数之后，它有一系列带标记的参数，这些参数列出了AP的功能。这些参数包括AP的SSID名称(与BSS ID相匹配的文本字符串)、它支持的数据速率以及它所运行的通道。</p><p><em>Q: What is the SSID of the main AP? This is one of the tagged parameters in the Beacon frame.</em></p><p><em>A：如下图，主AP的SSID为“djw”。</em></p><p><img src="image-20221201231341794.png" alt="image-20221201231341794"></p><p><em>Q: How often are Beacon frames sent for the main AP? You may find the Beacon interval given in the Beacon frame itself, or change the Time display to be show the interval since the last frame.  (Under View, select Time Display Format, and “Seconds Since Previous Displayed Packet”.)</em></p><p><em>A：如图，时间间隔为0.1024秒，约为10次/秒。</em></p><p><img src="image-20221201231717657.png" alt="image-20221201231717657"></p><p><em>Q: What data rates does the main AP support? The rates are listed under tagged parameters.</em></p><p><em>A：如图，支持的速率为1、2、5.5、6、9、11、12、18、24、36、48、54 Mbps（其中，1、2、5.5、11Mbps速率标记为“B”，这意味着它们是802.11b遗留速率而不是802.11g速率）。</em></p><p><img src="image-20221201232115714.png" alt="image-20221201232115714"></p><p><em>Q: What rate is the Beacon frame transmission? The answer to this question will be found on the  Radiotap header, or more conveniently displayed in the column you added in an earlier step.</em></p><p><em>A：可以从Radiotap报头中找到”Beacon frame”传输速率，如下图，为1.0 Mb/s。</em></p><p><img src="image-20221201232405366.png" alt="image-20221201232405366"></p><h6 id="Association"><a href="#Association" class="headerlink" title="Association"></a>Association</h6><p>一旦计算机通过信标或其他方式了解到AP，它必须与AP关联，并可能在使用无线网络之前对自己进行身份验证。我们将看到计算机向AP发送关联请求，直到它得到确认。如果关联成功，那么AP将返回一个关联响应，计算机将确认该响应。</p><p><em>Q: What are the Type and Subtype values of Association Request / Association Response frames?</em></p><p><em>A：依次查看类型为”Association …”的管理帧，可以得到关联请求/关联响应帧的类型和子类型值分别为0x0000和0x0001。</em></p><p><img src="image-20221201233301043.png" alt="image-20221201233301043"></p><p><img src="image-20221201233344648.png" alt="image-20221201233344648"></p><h6 id="Probe-Request-Response"><a href="#Probe-Request-Response" class="headerlink" title="Probe Request/Response"></a>Probe Request/Response</h6><p>最后，我们来简要了解探测帧。计算机可以探测特定的AP，而不是等待从信标处了解AP。探测请求(Probe Request)由计算机发送，用于测试具有特定SSID的AP是否在附近。如果被寻找的AP在附近，那么它将用探测响应进行回复。对于计算机来说，发送探测请求的无线网络是很常见的，它们以前用来加快连接到已知网络的速度。</p><p><em>Q: What are the Type and Subtype values for the Probe Request / Probe Response frames?</em></p><p><em>A：依次查看类型为”Probe …”的管理帧，可以得到关联请求/关联响应帧的类型和子类型值分别为0x0004和0x0005。</em></p><p><img src="image-20221201233856165.png" alt="image-20221201233856165"></p><p><img src="image-20221201233925568.png" alt="image-20221201233925568"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lab4-1 Wireshark-ethernet</title>
      <link href="/2022/12/29/CNLab4-1/"/>
      <url>/2022/12/29/CNLab4-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Lab4-1-Ethernet"><a href="#Lab4-1-Ethernet" class="headerlink" title="Lab4-1 Ethernet"></a>Lab4-1 Ethernet</h2><h4 id="1-Objective"><a href="#1-Objective" class="headerlink" title="1 Objective"></a>1 Objective</h4><p>了解以太网帧的详细信息。</p><h4 id="2-Requirements"><a href="#2-Requirements" class="headerlink" title="2 Requirements"></a>2 Requirements</h4><p>除Wireshark外，本实验要求能使用ping命令。</p><h4 id="3-Steps"><a href="#3-Steps" class="headerlink" title="3 Steps"></a>3 Steps</h4><h5 id="Step-1-Capture-a-Trace"><a href="#Step-1-Capture-a-Trace" class="headerlink" title="Step 1: Capture a Trace"></a>Step 1: Capture a Trace</h5><ol><li><p>选择一个远程web服务器或其他公共可达的Internet主机，使用ping发送一些ping消息，并检查它是否发送应答。如下图，这里选择了“ping www.baidu.com”。</p><p><img src="image-20221129103913595.png" alt="image-20221129103913595"></p></li><li><p>启动Wireshark，用”icmp“过滤器开始抓包，并在选项窗口里勾选”Resolve MAC address“，这样可以转换以太网(MAC)地址以提供供应商信息。取消勾选“混杂”，混杂模式对于在广播网络上窃听发送到/来自其他计算机的数据包时很有用，但在本实验中我们只想记录发送到/从本计算机发出的数据包。</p><p><img src="image-20221129114019893.png" alt="image-20221129114019893"></p><p><img src="image-20221129114030347.png" alt="image-20221129114030347"></p></li><li><p>抓包开始后，重复上面的ping命令，这样数据包就会被Wireshark记录下来。</p></li><li><p>待ping命令执行完成后，返回Wireshark并停止抓包，得到的结果如下图。</p><p><img src="image-20221129114503631.png" alt="image-20221129114503631"></p></li></ol><h5 id="Step-2-Inspect-the-Trace"><a href="#Step-2-Inspect-the-Trace" class="headerlink" title="Step 2: Inspect the Trace"></a>Step 2: Inspect the Trace</h5><p>选中数据包并查看其结构的详细信息和组成包的字节，如下图，可以看到开了MAC地址解析后，在MAC的源地址和目的地址都有一层解析。</p><p><img src="image-20221129114716848.png" alt="image-20221129114716848"></p><h5 id="Step-3-Ethernet-Frame-Structure"><a href="#Step-3-Ethernet-Frame-Structure" class="headerlink" title="Step 3: Ethernet Frame Structure"></a>Step 3: Ethernet Frame Structure</h5><p><em>To show your understanding of the Ethernet frame format, draw a figure of the ping message that shows the position and size in bytes of the Ethernet header fields.</em></p><div class="table-container"><table><thead><tr><th>Preamble</th><th>SFD</th><th>Destination Address</th><th>Source Address</th><th>Length/Type</th><th>DATA</th><th>Frame Check Sequence</th></tr></thead><tbody><tr><td>7 Byte</td><td>1 Byte</td><td>6 Byte</td><td>6 Byte</td><td>2 Byte</td><td>46~1500 Byte</td><td>4 Byte</td></tr></tbody></table></div><h5 id="Step-4-Scope-of-Ethernet-Addresses"><a href="#Step-4-Scope-of-Ethernet-Addresses" class="headerlink" title="Step 4: Scope of Ethernet Addresses"></a>Step 4: Scope of Ethernet Addresses</h5><p>每个以太网帧都携带一个源地址和目的地址，其中一个地址就是本地电脑地址。它是发送帧的源，接收帧的目的地，那么另一个地址是什么？当我们 ping 一个远程Internet服务器的时候，我们输入的是域名，经过DNS解析后得到IP地址，我们与目的服务器必然不是直接链接的关系，这中间发生了什么呢？</p><p><em>Draw a figure that shows the relative positions of your computer, the router, and the remote server. Label your computer and the router with their Ethernet addresses. Label your computer and the remote  server with their IP addresses. Show where the Ethernet and the rest of the Internet fit on the drawing.</em></p><p><img src="image-20221130172601068.png" alt="image-20221130172601068"></p><p><img src="image-20221130205448670.png" alt="image-20221130205448670"></p><h5 id="Step-5-Broadcast-Frames"><a href="#Step-5-Broadcast-Frames" class="headerlink" title="Step 5: Broadcast Frames"></a>Step 5: Broadcast Frames</h5><p>接下来的部分，可以直接用附件里的”trace-ethernet.pcap”来进行探究。</p><p><em>1. What is the broadcast Ethernet address, written in standard form as Wireshark displays it?</em></p><p>如图可知，地址为 FF:FF:FF:FF:FF:FF 。</p><p><img src="image-20221130210423289.png" alt="image-20221130210423289"></p><p><em>2. Which bit of the Ethernet address is used to determine whether it is unicast or multicast/broadcast?</em></p><p>第8个bit（第一个字节的最低位）。</p><p>如果该位为0，则是某台设备的MAC地址，即单播地址；如果该位为1，则是多播地址（组播+广播=多播）。</p><p><img src="image-20221130211047548.png" alt="image-20221130211047548"></p><h4 id="4-Explore-on-your-own-IEEE-802-3"><a href="#4-Explore-on-your-own-IEEE-802-3" class="headerlink" title="4 Explore on your own (IEEE 802.3)"></a>4 Explore on your own (IEEE 802.3)</h4><p><em>1. How long are the combined IEEE 802.3 and LLC headers compared to the DIX Ethernet headers? You can use Wireshark to work this out. Note that the Trailer/Padding and Checksum may be  shown as part of the header, but they come at the end of the frame.</em></p><p>IEEE 802.3与DIX Ethernet一样，报头长度为14 bytes。LLC加入了3 bytes的长度，总长度为17 bytes。</p><p><img src="image-20221130211741035.png" alt="image-20221130211741035"></p><p><img src="image-20221130211758296.png" alt="image-20221130211758296"></p><p><em>2. How does the receiving computer know whether the frame is DIX Ethernet or IEEE 802.3? Hint:  you may need to both use Wireshark to look at packet examples and read your text near where the Ethernet formats are described.</em> </p><p>“DIX Ethernet Type”字段和“IEEE 802.3 Length”字段的位置相同。如果该值小于Ox600(1536)，则将其解释为Length值。如果该值大于Ox600(1536)，则将其解释为Type值。</p><p><em>3. If IEEE 802.3 has no Type field, then how is the next higher layer determined? Use Wireshark to  look for the demultiplexing key.</em></p><p>IEEE 802.3在IEEE 802.3报头之后立即添加LLC报头，以传递下一层协议，这从上面的两张图中也能看出来。</p><p>p.s. LLC使用一个称为DSAP的初始字节，而不是Type字段中的两个字节。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lab1-2 Wireshark-protocal layers</title>
      <link href="/2022/12/29/CNLab1-2/"/>
      <url>/2022/12/29/CNLab1-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Lab1-2-Protocol-Layers"><a href="#Lab1-2-Protocol-Layers" class="headerlink" title="Lab1-2 Protocol Layers"></a>Lab1-2 Protocol Layers</h2><h4 id="1-Objective"><a href="#1-Objective" class="headerlink" title="1 Objective"></a>1 Objective</h4><p>了解如何在数据包中表示协议和分层。</p><h4 id="2-Requirements"><a href="#2-Requirements" class="headerlink" title="2 Requirements"></a>2 Requirements</h4><p>实验指导书中该部分分为Wireshark软件安装和wget（或curl）安装，Wireshark安装之前已经记录过了，这里就只写wget的获取了。</p><h5 id="2-1-下载安装wget"><a href="#2-1-下载安装wget" class="headerlink" title="2.1 下载安装wget"></a>2.1 下载安装wget</h5><p>前往<a href="https://eternallybored.org/misc/wget/">GNU Wget 1.21.3 for Windows (eternallybored.org)</a>下载wget，这里选择了1.21.3—64bit—ZIP。</p><h5 id="2-2-配置环境变量"><a href="#2-2-配置环境变量" class="headerlink" title="2.2 配置环境变量"></a>2.2 配置环境变量</h5><p>将文件解压到的路径添加至环境变量。</p><h5 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h5><p>若成功显示wget版本即说明安装成功。</p><p><img src="image-20221128221711788.png" alt="image-20221128221711788"></p><h4 id="3-Steps"><a href="#3-Steps" class="headerlink" title="3 Steps"></a>3 Steps</h4><h5 id="Step-1-Capture-a-Trace"><a href="#Step-1-Capture-a-Trace" class="headerlink" title="Step 1: Capture a Trace"></a>Step 1: Capture a Trace</h5><ol><li><p>使用wget获取输入的URL的资源，如果状态代码为”200 OK“则说明获取成功，如下图。</p><p><img src="image-20221129034710216.png" alt="image-20221129034710216"></p></li><li><p>关闭不必要的浏览器选项卡和窗口，通过最小化浏览器活动来阻止计算机获取不必要的web内容，避免在追踪过程中的偶然的流量。</p></li><li><p>启动Wireshark，用”tcp port 80“过滤器开始抓包，并在选项窗口里勾选”Resolve network names“。这个过滤器将只记录标准的网络流量，而不记录计算机可能发送的其他类型的包。勾选的作用是将把发送和接收数据包的计算机的地址转换为名称，这将帮助我们识别数据包是发送到计算机的还是计算机发送出去的。</p><p><img src="image-20221128223758803.png" alt="image-20221128223758803"></p><p><img src="image-20221128223906894.png" alt="image-20221128223906894"></p></li><li><p>抓包开始时，使用wget重复web获取，这次的报文就会在传输过程中会被Wireshark记录下来。</p></li><li><p>获取成功后，返回Wireshark并停止抓包。如果成功了的话，Wireshark窗口将显示多个包。捕获的包的个数取决于web页面的大小，通常为20到100个，至少有8个。如下图，本次共抓取了11个（正常包有8个）。</p><p><img src="image-20221129034513536.png" alt="image-20221129034513536"></p></li></ol><h5 id="Step-2-Inspect-the-Trace"><a href="#Step-2-Inspect-the-Trace" class="headerlink" title="Step 2: Inspect the Trace"></a>Step 2: Inspect the Trace</h5><p>我们可以选中一个数据包来查看它的协议层。这里我们选择一个”Protocol“（协议）列为”HTTP“且”Info“（信息）列为”GET“开头的数据包，可以看到共四层协议，分别为以太网、IP(IPv4)、TCP和HTTP。</p><p><img src="image-20221129034647595.png" alt="image-20221129034647595"></p><p>注意，顺序是从协议栈的底部向上的。这是因为当数据包沿着堆栈向下传递时，底层协议的头信息被添加到来自上层协议的信息前面。也就是说，下层协议在“线上”数据包中首先出现。</p><p>接下来找到对应从服务器到本机的响应的另一个”HTTP“数据包，这个包的Info字段中应该有“200 OK”，表示获取成功。与HTTP GET包对比，可以看到其有两个额外的部分，如下图所示。</p><p><img src="image-20221129034803774.png" alt="image-20221129034803774"></p><p>第一个额外的部分写着“[2 Reassembled TCP Segments (2497 bytes): #6(1452), #7(1045)]”，它是关于如何将从服务器发往本机的数据包按顺序组合起来的（因为web响应是通过发送一系列数据包到计算机来实现的，标记为HTTP的数据包是web响应的最后一个数据包）。虽然这些数据包携带着部分HTTP相应，但当前他们每一个都显示有”TCP“。只有最后的包显示为具有HTTP协议时，它们才被组合成一个完整的 HTTP 响应。</p><p>第二个额外的部分写着”Line-based text data: text/html (2 lines)“，它描述的是所获取的网页的内容。这不是一个真正的协议，它是Wireshark正在生成的包内容的描述，以帮助我们理解网络流量。</p><h5 id="Step-3-Packet-Structure"><a href="#Step-3-Packet-Structure" class="headerlink" title="Step 3: Packet Structure"></a>Step 3: Packet Structure</h5><p><em>To show your understanding of packet structure, draw a figure of an HTTP GET packet that shows the  position and size in bytes of the TCP, IP and Ethernet protocol headers.</em></p><div class="table-container"><table><thead><tr><th>Ethernet</th><th>IP</th><th>TCP</th><th>HTTP</th></tr></thead><tbody><tr><td>14B</td><td>20B</td><td>20B</td><td>128B</td></tr><tr><td>Ethernet Header</td><td>Ethernet Payload</td><td>~</td><td>~</td></tr><tr><td></td><td>IP Header</td><td>IP Payload</td><td>~</td></tr><tr><td></td><td></td><td>TCP Header</td><td>TCP Payload</td></tr></tbody></table></div><p><img src="image-20221129041434626.png" alt="image-20221129041434626"></p><h5 id="Step-4-Protocol-Overhead"><a href="#Step-4-Protocol-Overhead" class="headerlink" title="Step 4: Protocol Overhead"></a>Step 4: Protocol Overhead</h5><p><em>Estimate the download protocol overhead, or percentage of the download bytes taken up by protocol  overhead. To do this, consider HTTP data (headers and message) to be useful data for the network to  carry, and lower layer headers (TCP, IP, and Ethernet) to be the overhead.</em></p><p>可以通过对Destination列进行排序来只查看下载方向的数据包。数据包应该以一个描述为[SYN ACK]的短TCP包开始，这是连接的开始。接下来，是较大的TCP包（大约1到1.5KB）。最后一个是HTTP包（也可能以一个短的TCP包结束，它是结束连接的一部分）。</p><p><img src="image-20221129035044873.png" alt="image-20221129035044873"></p><p>对于每个包，我们可以检查它以Ethernet/IP/TCP报头的形式有多少开销，以及它在TCP有效负载中携带了多少有用的HTTP数据。</p><p>我们依次选中数据包，可以看到下载过程数据总长度为：66 + 56 + 1506 + 1099 = 2727 bytes，HTTP数据长度为：1045 bytes，所以下载开销占比为：(2727-1045)/2727≈61.7％。</p><p><img src="image-20221129040200799.png" alt="image-20221129040200799"></p><p>下载协议开销很重要，它保证了数据传输的正确性和可恢复性。因为这里我们的GET请求数据包较短，所以下载协议开销较大。额外的开销部分虽然不是定长，但是基本是在一个较为确定的范围内，只要GET请求的内容包括更多的信息，只要数据包足够大，额外开销的占比就会趋近于0。</p><h5 id="Step-5-Demultiplexing-Keys"><a href="#Step-5-Demultiplexing-Keys" class="headerlink" title="Step 5: Demultiplexing Keys"></a>Step 5: Demultiplexing Keys</h5><p>解复用（Demultiplexing）：当数据包从交给上层进行处理时，需要找到正确的上层协议，这个过程就叫做解复用。</p><p>解复用键（Demultiplexing Keys）：在协议头中来指明上层协议的信息。</p><p><em>1. Which Ethernet header field is the demultiplexing key that tells it the next higher layer is IP?  What value is used in this field to indicate “IP”?</em></p><p>如图：Type；0x0800。</p><p><img src="image-20221129041859851.png" alt="image-20221129041859851"></p><p><em>2. Which IP header field is the demultiplexing key that tells it the next higher layer is TCP? What  value is used in this field to indicate “TCP”?</em></p><p>如图：Protocol；0x06。</p><p><img src="image-20221129041934849.png" alt="image-20221129041934849"></p><h4 id="4-Explore-on-your-own"><a href="#4-Explore-on-your-own" class="headerlink" title="4 Explore on your own"></a>4 Explore on your own</h4><p> <em>Look at a short TCP packet that carries no higher-layer data. To what entity is this packet destined? After all, if it carries no higher-layer data then it does not seem very useful to a higher layer protocol such as HTTP!</em></p><p>下图就是一个不包含更高层数据的TCP数据包。</p><p><img src="image-20221129042407851.png" alt="image-20221129042407851"></p><p>在TCP协议中，建立连接需要三次握手，结束连接需要4次挥手。这几次的数据传递均是不包括高层协议数据的，目的是为了确保连接建立的稳定和准确。</p><p><em>In a classic layered model, one message from a higher layer has a header appended by the lower  layer and becomes one new message. But this is not always the case. Above, we saw a trace in  which the web response (one HTTP message comprised of an HTTP header and an HTTP payload) was converted into multiple lower layer messages (being multiple TCP packets). Imagine  that you have drawn the packet structure (as in step 2) for the first and last TCP packet carrying  the web response. How will the drawings differ?</em> </p><p>第一个包的首部中，Connection字段的值为：keep-alive，表明后续仍有数据。最后一个包请求头中Connection字段的值为：close，表明传输结束，同时最后一个包中还会包含FIN=1来请求关闭连接。</p><p><em>In the classic layered model described above, lower layers append headers to the messages  passed down from higher layers. How will this model change if a lower layer adds encryption?</em> </p><p>加密的目的是为了保密内容，所以加密的类型和加密密钥不能随着加密数据一同发送，而是应该在传输数据前根据加密协议进行协商确定。</p><p><em>In the classic layered model described above, lower layers append headers to the messages  passed down from higher layers. How will this model change if a lower layer adds compression?</em></p><p>压缩的目的是为了节省传输流量，所以压缩的协议可直接在下层协议头中指明，便于接收方解压缩。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lab1-1 Wireshark_Intro_v7.0</title>
      <link href="/2022/12/29/CNLab1-1/"/>
      <url>/2022/12/29/CNLab1-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Lab1-1-Getting-Started"><a href="#Lab1-1-Getting-Started" class="headerlink" title="Lab1-1 Getting Started"></a>Lab1-1 Getting Started</h2><h4 id="1-Getting-Wireshark"><a href="#1-Getting-Wireshark" class="headerlink" title="1 Getting Wireshark"></a>1 Getting Wireshark</h4><p>从 <a href="http://www.wireshark.org/download.html">http://www.wireshark.org/download.html</a> 下载并安装Wireshark。</p><h4 id="2-Running-Wireshark"><a href="#2-Running-Wireshark" class="headerlink" title="2 Running Wireshark"></a>2 Running Wireshark</h4><p>Wireshark初始界面：</p><p><img src="image-20221127193758653.png" alt="image-20221127193758653"></p><p>双击接口名称即可进入对应接口进行抓包，如进入WLAN接口：</p><p><img src="image-20221127194333009.png" alt="image-20221127194333009"></p><p>抓包界面可大致分为以下五部分：</p><p><img src="image-20221127200002502.png" alt="image-20221127200002502"></p><ol><li>命令菜单：常用的是”文件“和”捕获“菜单。“文件”菜单可以保存抓包数据，也可以打开以前的抓包数据文件，还有退出Wireshark应用程序等。“捕获”菜单可以允许我们开始或停止抓包。</li><li>数据包列表窗口：显示每一个捕获包的一行摘要，包括包号、数据包被捕获的时间、数据包的源地址和目的地址、协议类型以及数据包中包含的特定于协议的信息。</li><li>包头详细信息窗口：提供了包列表窗口中选中的包的详细信息。这些详细信息包括以太网帧(假设数据包通过以太网接口发送/接收)和包含该数据包的IP数据报的信息。</li><li>数据包内容窗口：以ASCII和十六进制格式显示捕获帧的全部内容。</li><li>包过滤显示区域：可以在其中输入协议名或其他信息，以便过滤包列表窗口(以及包头和包内容窗口)中显示的信息。</li></ol><h4 id="3-Taking-Wireshark-for-a-Test-Run"><a href="#3-Taking-Wireshark-for-a-Test-Run" class="headerlink" title="3 Taking Wireshark for a Test Run"></a>3 Taking Wireshark for a Test Run</h4><p>试运行Wireshark来学习其使用流程。</p><ol><li><p>打开浏览器。</p></li><li><p>打开Wireshark软件。</p></li><li><p>选择“捕获”下拉菜单并选择“选项”，打开”Wireshark·捕获选项“。</p><p><img src="image-20221127202204806.png" alt="image-20221127202204806"></p></li><li><p>选中要开始抓包的接口，然后点击”开始“。</p></li><li><p>开始抓包之后，选择“抓包”下拉菜单并选择“停止”，可以停止抓包（但是现在先不要停止抓包）。</p></li><li><p>当Wireshark正在运行时，在浏览器中打开：<a href="http://gaia.cs.umass.edu/wireshark-labs/INTRO-wireshark-filel.html。为了显示此页面，浏览器将在">http://gaia.cs.umass.edu/wireshark-labs/INTRO-wireshark-filel.html。为了显示此页面，浏览器将在</a> <em>gaia.cs.umass.edu</em> 与HTTP服务器联系，并与服务器交换HTTP消息以下载此页面。包含这些HTTP消息的以太网帧(以及通过以太网适配器的所有其他帧)将被Wireshark捕获。</p></li><li><p>在浏览器显示下面的页面后，点击停止按钮，现在可以在已捕获包列表中看到通过这个网络接口的所有的数据包。</p><p><img src="image-20221127203421287.png" alt="image-20221127203421287"></p></li><li><p>在应用显示过滤器窗口中输入“http”，然后选择Apply(在输入“http”的右侧)。这将导致在包列表窗口中只显示HTTP消息。</p><p><img src="image-20221127203915269.png" alt="image-20221127203915269"></p></li><li><p>查看HTTP GET信息。当选择HTTP GET消息时，将在报文报头窗口中显示以太网帧、IP数据报、TCP段和HTTP消息报头信息。</p><p><img src="image-20221127204445952.png" alt="image-20221127204445952"></p></li><li><p>退出Wireshark。</p></li></ol><h4 id="4-What-to-hand-in（Questions）"><a href="#4-What-to-hand-in（Questions）" class="headerlink" title="4 What to hand in（Questions）"></a>4 What to hand in（Questions）</h4><p><em>1. List 3 different protocols that appear in the protocol column in the unfiltered  packet-listing window in step 7 above.</em></p><p>如下图，OICQ，TCP，UDP。</p><p><img src="image-20221127204731876.png" alt="image-20221127204731876"></p><p><em>2.  How long did it take from when the HTTP GET message was sent until the HTTP  OK reply was received? (By default, the value of the Time column in the packet-listing window is the amount of time, in seconds, since Wireshark tracing began.  To display the Time field in time-of-day format, select the Wireshark View pull  down menu, then select Time Display Format, then select Time-of-day.)</em></p><p>如下图，约为0.241秒。</p><p><img src="image-20221127205727136.png" alt="image-20221127205727136"></p><p><em>3. What is the Internet address of the gaia.cs.umass.edu (also known as wwwnet.cs.umass.edu)? What is the Internet address of your computer?</em></p><p>如图，<em>gaia.cs.umass.edu</em> 的地址为128.119.245.12，本机地址为172.25.192.244。</p><p><img src="image-20221127205827144.png" alt="image-20221127205827144"></p><p><em>4. Print the two HTTP messages (GET and OK) referred to in question 2 above. To do so, select Print from the Wireshark File command menu, and select the “Selected Packet Only” and “Print as displayed” radial buttons, and then click OK.</em></p><p>如果，点击”确定“即可打印。</p><p><img src="image-20221127210357704.png" alt="image-20221127210357704"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2022/12/29/testblog/"/>
      <url>/2022/12/29/testblog/</url>
      
        <content type="html"><![CDATA[<h4 id="似乎有点晚"><a href="#似乎有点晚" class="headerlink" title="似乎有点晚"></a>似乎有点晚</h4><p>建立一个博客来记录学习生活及平时的心理历程等。</p><p>这里是公式测试</p><p>$a^b$</p><p>这里是图片测试</p><p><img src="f0.jpg" alt="测试图片"></p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> testtag </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
