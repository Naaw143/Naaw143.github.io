<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2022blog</title>
      <link href="/2023/01/01/2022blog/"/>
      <url>/2023/01/01/2022blog/</url>
      
        <content type="html"><![CDATA[<h4 id="很奇怪"><a href="#很奇怪" class="headerlink" title="很奇怪"></a>很奇怪</h4><p>没什么感觉的跨年……之前每每跨年时，都会感觉有好多话想说，有种写年度总结然后发出来的冲动，但今年（或者用去年更合适，但想来还是用今年更舒服，这里就当今年还是2022吧）不太一样，今年完全没什么跨年的特殊感觉，只是单纯觉得又一年过去了仅此而已，我甚至没意识到是跨年，零点时收到朋友们的跨年祝福才想起已经2023了（里面竟然有几年没说过话的前前女友的祝福，乐），可能是因为今年跨年在家，睡得早了些吧 : ) 。</p><p>但又很奇怪的是，之前感概颇深，却没有一次真的发出年度总结（甚至没写），这次没什么感觉，此时此刻却正在写年度总结……想来大抵是因为之前没有建博客，想发就只能发到空间和朋友圈，而我又是对空间or朋友圈有些抵触的——大概就是，觉得想分享的事，朋友早就告诉过了，不熟的也没有必要告诉，又觉得空间就是展现自己的，而从某些事后我变得对自己缺乏自信，也就不想发空间了。</p><h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h4><p>总的来说，这一年过的并不好。</p><p>前半年，我过于沉浸虚拟世界之中，追求一些虚拟的荣誉（倒是也确实取得了一些，但那些又有什么用呢，哈哈哈），与之相伴的就是现实世界的事儿草草应付，整个大二下学期的作业都是临ddl才做，有时候赶不完，就找些资料cv了，考试也是考前几天猛补进度，基本上学一遍就去考试了，最后的成绩也想当然的低。唉，当时竟然还觉得无所谓……</p><p>但也幸好，这种情况到了大三有所改善，我退坑了之前的游戏，这种重新感受现实世界的感觉还不错。这学期的作业都基本都是提前做，大作业和实验也基本保证了独立完成，当然有不会的还是得请教各位佬。这种靠自己的感觉帮助我找回了一些自信，我发现有些之前觉得难于登天的科目，其实不过如此，是我之前没学就尝试做题，从什么不懂的视角来看，才看的一头雾水 : ( ，哈哈，有点搞笑。之前觉得枯燥的科目竟然也变得生动有趣起来，我有些后悔没有认真钻研之前的科目，同时也庆幸考试延期，有了更多时间来学习当下的科目。我竟然重新变得对学习有兴趣了？乐，希望这种状态能持续下去。</p><p>感觉这半年的心态也发生了一些变化吧，我似乎变得冷漠了很多，不再像之前一样时刻关注周围人的情绪，但这样更多把关注点放在自己身上，倒让我感觉舒服很多并想继续这样下去。</p><p>不过我似乎也一直是个冷漠的人，不然也不会在2022年将w从身边推走吧。</p><h4 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h4><p>希望2023能在实验室做出点东西来，然后夏令营能有一个好去向吧。</p><p>也希望能找回过去的自己。</p><h4 id="end"><a href="#end" class="headerlink" title="end"></a>end</h4><p>就先写这么多吧，想到哪儿写到哪儿，有些乱。</p>]]></content>
      
      
      <categories>
          
          <category> personal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lab7-2 Wireshark-HTTP</title>
      <link href="/2022/12/29/CNLab7-2/"/>
      <url>/2022/12/29/CNLab7-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Lab7-2-HTTP"><a href="#Lab7-2-HTTP" class="headerlink" title="Lab7-2 HTTP"></a>Lab7-2 HTTP</h2><h4 id="1-Objective"><a href="#1-Objective" class="headerlink" title="1 Objective"></a>1 Objective</h4><p>通过实验了解HTTP(超文本传输协议)的主要信息。HTTP是Web的主要协议。</p><h4 id="2-Steps"><a href="#2-Steps" class="headerlink" title="2 Steps"></a>2 Steps</h4><h5 id="Step-1-Capture-a-Trace"><a href="#Step-1-Capture-a-Trace" class="headerlink" title="Step 1: Capture a Trace"></a>Step 1: Capture a Trace</h5><p>实验手册中提供了本实验的抓包结果，可以直接点击<a href="https://kevincurran.org/com320/labs/wireshark/trace-http.pcap">链接</a>下载。</p><p><img src="/2022/12/29/CNLab7-2/image-20221203071853706.png" alt="image-20221203071853706"></p><h5 id="Step-2-Inspect-the-Trace"><a href="#Step-2-Inspect-the-Trace" class="headerlink" title="Step 2: Inspect the Trace"></a>Step 2: Inspect the Trace</h5><p>我们可以在应用显示过滤器中输入http来只查看http请求或响应包。</p><p><img src="/2022/12/29/CNLab7-2/image-20221203071048252.png" alt="image-20221203071048252"></p><p>选择第一个HTTP请求包并展开它的HTTP块，查看其详细信息：</p><p><img src="/2022/12/29/CNLab7-2/image-20221203071930276.png" alt="image-20221203071930276"></p><ul><li>“Host”是一个必须有的头部，它标识了服务器的名称（和端口）。</li><li>“User-Agent”描述了浏览器的类型及其功能。</li><li>“Accept”、”Accept-Encoding”、”Accept-Charset”和”Accept-Language”对应了响应中接受的格式的描述。</li><li>“Cookie”是浏览器为网站保存的cookie的名称和值。</li><li>“Cache-Control”描述了如何缓存响应。</li></ul><p>选择与第一个HTTP请求包对应的HTTP响应包并展开它的HTTP块，查看其详细信息：</p><p><img src="/2022/12/29/CNLab7-2/image-20221203072659127.png" alt="image-20221203072659127"></p><ul><li>“Server”描述了服务器的类型及其功能。</li><li>“Date”和”Last-Modified”描述了响应的时间和内容最后更改的时间。</li><li>“Cache-Control”、”Expires”和”Etag”是关于如何缓存响应的信息。</li></ul><p><em>What is the format of a header line? Give a simple description that fits the headers you see.</em></p><p><em>对HTTP请求来说，header line由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。</em></p><p><img src="/2022/12/29/CNLab7-2/image-20221203073404456.png" alt="image-20221203073404456"></p><p><em>对HTTP响应来说，header line由服务器HTTP协议版本、服务器发回的响应状态代码和状态代码的文本描述3个字段组成，它们用空格分隔。</em></p><p><img src="/2022/12/29/CNLab7-2/image-20221203073418051.png" alt="image-20221203073418051"></p><p><em>What headers are used to indicate the kind and length of content that is returned in a response?</em></p><p><em>如图，为”Content-Type”和”Content-Length”。</em></p><p><img src="/2022/12/29/CNLab7-2/image-20221203074148726.png" alt="image-20221203074148726"></p><h5 id="Step-3-Content-Caching"><a href="#Step-3-Content-Caching" class="headerlink" title="Step 3: Content Caching"></a>Step 3: Content Caching</h5><p>通过查看抓包结果我们可以发现，抓包结果中的第二个GET包应该是第一个URL的重新获取。这为我们提供了一个查看缓存操作的机会，因为很有可能图像或文档没有更改，因此不需要再次下载，HTTP缓存机制应该能够识别这种机会。现在我们来看看它们是如何工作的。</p><p>选择第一个GET的重新获取的GET，并展开它的HTTP块。</p><p><img src="/2022/12/29/CNLab7-2/image-20221203075022337.png" alt="image-20221203075022337"></p><p>现在找到让服务器判断是否需要发送新内容的报头。只有当内容自浏览器上次下载后发生了更改时，服务器才需要发送新内容。为了解决这个问题，浏览器包含一个时间戳，从上一次下载中获取它缓存的内容。这个头没有出现在第一个GET包中，因为我们清除了浏览器缓存，所以浏览器没有以前下载的可以使用的内容。在大多数其他方面，这个请求将与第一次请求相同。</p><p>最后，选择要重新获取的响应包，并查看它的HTTP块。</p><p><img src="/2022/12/29/CNLab7-2/image-20221203080007795.png" alt="image-20221203080007795"></p><p>假设缓存按预期工作，此响应将不包含内容。相反，响应的状态代码将是“304 Not Modified”。这将告诉浏览器，内容与以前的副本没有变化，然后可以显示缓存的内容。</p><p><em>What is the name of the header the browser sends to let the server work out whether to send  fresh content?</em></p><p><em>这个报头叫做”If - Modified - Since”，也就是说，它要求服务器发送自给定时间以来是否被修改过的内容(如下图)。</em></p><p><img src="/2022/12/29/CNLab7-2/image-20221203075508047.png" alt="image-20221203075508047"></p><p><em>Where exactly does the timestamp value carried by the header come from?</em></p><p><em>时间戳值来自最近下载的内容的“Last-Modified”报头。</em></p><h5 id="Step-4-Complex-Pages"><a href="#Step-4-Complex-Pages" class="headerlink" title="Step 4: Complex Pages"></a>Step 4: Complex Pages</h5><p>现在我们将检查第四个HTTP请求（实验手册中说第三个，但第三个是”&#x2F;favicon.ico”的GET，这是浏览器请求站点的图标作为浏览器显示的一部分）。这种获取方法适用于更复杂的web页面，其中可能包含嵌入式资源。因此，浏览器将下载初始HTML加上渲染页面所需的所有嵌入式资源，再加上执行页面脚本期间请求的其他资源。正如我们将看到的，单个页面可以涉及多个GET。</p><p>我们可以通过打开一个”统计-HTTP”中的负载分配面板来总结本页的GET，查看这个面板将显示本机向哪些服务器发出了多少请求。</p><p><img src="/2022/12/29/CNLab7-2/image-20221203081819906.png" alt="image-20221203081819906"></p><p>我们也可以通过打开一个”统计-HTTP”中的分组计数器面板来总结本页的GET，这个面板显示了请求和响应的类型。</p><p><img src="/2022/12/29/CNLab7-2/image-20221203082001645.png" alt="image-20221203082001645"></p><p>可以使用一个网站如谷歌的<a href="https://developers.google.com/speed/pagespeed/insights/">PageSpeed</a>或<a href="https://www.webpagetest.org/">ebpagetest.org</a>来更详细地了解整个页面加载过程。这些网站将测试已选择的URL，并生成页面加载活动的报告，显示在什么时间获取了什么请求，并给出减少整体页面加载时间的提示。</p><p><a href="https://pagespeed.web.dev/report?url=https://www.bilibili.com/&form_factor=desktop">使用PageSpeed对B站测试</a>。</p><p><img src="/2022/12/29/CNLab7-2/image-20221203083434334.png" alt="image-20221203083434334"></p><p><a href="https://www.webpagetest.org/result/221203_AiDc70_9B/">使用ebpagetest.org对泰山学堂官网进行测试</a>。</p><p>得到的瀑布图如下。</p><p><img src="/2022/12/29/CNLab7-2/image-20221229192032442.png" alt="image-20221229192032442"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lab7-1 Wireshark_DNS</title>
      <link href="/2022/12/29/CNLab7-1/"/>
      <url>/2022/12/29/CNLab7-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Lab7-1-DNS"><a href="#Lab7-1-DNS" class="headerlink" title="Lab7-1 DNS"></a>Lab7-1 DNS</h2><h4 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h4><p>域名系统(DNS)将主机名转换为IP地址，在互联网基础设施中发挥着关键作用。</p><h4 id="2-Steps"><a href="#2-Steps" class="headerlink" title="2 Steps"></a>2 Steps</h4><h5 id="Step-1-nslookup"><a href="#Step-1-nslookup" class="headerlink" title="Step 1: nslookup"></a>Step 1: nslookup</h5><p>简单介绍几种常用的nslookup命令：</p><ul><li><p>“nslookup <a href="http://www.mit.edu",意为“请给我发送主机www.mit.edu的ip地址”./">www.mit.edu&quot;，意为“请给我发送主机www.mit.edu的IP地址”。</a></p><p><img src="/2022/12/29/CNLab7-1/image-20221203000122497.png" alt="image-20221203000122497"></p></li><li><p>“nslookup –type&#x3D;NS mit.edu”，意为”请把mit.edu的权威DNS的主机名发给我“，当不使用-type选项时，nslookup使用默认值，即查询A类型的记录。</p><p><img src="/2022/12/29/CNLab7-1/image-20221203000137389.png" alt="image-20221203000137389"></p></li><li><p>“nslookup <a href="http://www.aiit.or.kr/">www.aiit.or.kr</a> bitsy.mit.edu”，使用这个命令，我们将会将查询发送到DNS服务器bitsy.mit.edu，而不是缺省DNS服务器(DNS -prime.poly.edu)，即查询和回复直接发生在我们的查询主机和bitsy.mit.edu之间。</p><p>这里一直显示超时，估计是地域原因（主机<a href="http://www.aiit.or.kr是韩国高级信息技术学院的web服务器)./">www.aiit.or.kr是韩国高级信息技术学院的web服务器）。</a></p><p><img src="/2022/12/29/CNLab7-1/image-20221203000222701.png" alt="image-20221203000222701"></p></li><li><p>“nslookup –option1 –option2 host-to-find dns-server”是nslookup的一般语法，我们可以看到，nslookup可以在0个、1个、2个或多个选项的情况下运行（dns-server也是可选的）。</p></li></ul><p><em>1. Run nslookup to obtain the IP address of a Web server in Asia. What is the IP address of that server?</em> </p><p><em>如图，获取到”<a href="http://www.sdu.edu.cn"的IP地址为202.194.7.118（2001:da8:7000:7:202:194:7:118为IPv6地址）。">www.sdu.edu.cn&quot;的IP地址为202.194.7.118（2001:da8:7000:7:202:194:7:118为IPv6地址）。</a></em></p><p><img src="/2022/12/29/CNLab7-1/image-20221203000744223.png" alt="image-20221203000744223"></p><p><em>2. Run nslookup to determine the authoritative DNS servers for a university in Europe.</em> </p><p><em>这里选择了剑桥大学。</em></p><p><img src="/2022/12/29/CNLab7-1/image-20221203051444665.png" alt="image-20221203051444665"></p><p><em>3. Run nslookup so that one of the DNS servers obtained in Question 2 is queried for the mail servers for Yahoo! mail. What is its IP address?</em></p><p><em>如下图，这里试了很多个问题2中的DNS服务器都显示找不到，最后就查了剑桥大学来代替了。得到的IP地址为128.232.132.8。</em></p><p><img src="/2022/12/29/CNLab7-1/image-20221203051742327.png" alt="image-20221203051742327"></p><h5 id="Step-2-ipconfig"><a href="#Step-2-ipconfig" class="headerlink" title="Step 2: ipconfig"></a>Step 2: ipconfig</h5><p>ipconfig可以用来显示当前的TCP&#x2F;IP信息，包括本机的地址、DNS服务器地址、适配器类型等，我们使用”ipconfig &#x2F;all”命令来获得以上提到的所有信息。</p><p><img src="/2022/12/29/CNLab7-1/image-20221203052522889.png" alt="image-20221203052522889"></p><p>ipconfig对于管理存储在主机中的DNS信息也非常有用，比如我们可以使用”ipconfig &#x2F;displaydns”命令来查看主机缓存的最近获得的DNS记录。</p><p><img src="/2022/12/29/CNLab7-1/image-20221203052837255.png" alt="image-20221203052837255"></p><p>我们也可以通过输入”ipconfig &#x2F;flushdns”命令来清除缓存。</p><p><img src="/2022/12/29/CNLab7-1/image-20221203053019621.png" alt="image-20221203053019621"></p><p>Step 3: Tracing DNS with Wireshark</p><p>现在我们将通过Wireshark来追踪DNS。首先，使用”ipconfig &#x2F;flushdns”命令来清楚DNS缓存。然后在Wireshark中使用”ip.addr &#x3D;&#x3D; 192.168.254.245”（这里的192.168.56.1是本机IP地址）过滤器（这个过滤器将删除既不从本地主机发出也不发往本地主机的所有数据包）来开始抓包。最后，使用浏览器浏览一个网页，如这里实验手册提供的”<a href="http://www.ietf.org".抓包结果如下图./">http://www.ietf.org&quot;。抓包结果如下图。</a></p><p><img src="/2022/12/29/CNLab7-1/image-20221203054524747.png" alt="image-20221203054524747"></p><p><em>4. Locate the DNS query and response messages. Are then sent over UDP or TCP?</em>  </p><p><em>如下图，通过UDP发送。</em></p><p><img src="/2022/12/29/CNLab7-1/image-20221203055016658.png" alt="image-20221203055016658"></p><p><em>5. What is the destination port for the DNS query message? What is the source port  of DNS response message?</em> </p><p><em>由下面两图可知，DNS查询消息的目的端口和DNS响应消息的源端口都为53。</em></p><p><img src="/2022/12/29/CNLab7-1/image-20221203055905381.png" alt="image-20221203055905381"></p><p><img src="/2022/12/29/CNLab7-1/image-20221203055928083.png" alt="image-20221203055928083"></p><p><em>6. To what IP address is the DNS query message sent? Use ipconfig to determine the IP address of your local DNS server. Are these two IP addresses the same?</em>  </p><p><em>DNS查询消息发送到的IP地址为192.168.254.245，使用 ipconfig 确定的本地 DNS 服务器的 IP 地址也为192.168.254.245。对比可以发现，二者相同。</em></p><p><img src="/2022/12/29/CNLab7-1/image-20221203055349865.png" alt="image-20221203055349865"></p><p><img src="/2022/12/29/CNLab7-1/image-20221203055330579.png" alt="image-20221203055330579"></p><p><em>7. Examine the DNS query message. What “Type” of DNS query is it? Does the  query message contain any “answers”?</em> </p><p><em>如下图，为A类型（也有AAAA类型），没有答案。</em></p><p><img src="/2022/12/29/CNLab7-1/image-20221203060313173.png" alt="image-20221203060313173"></p><p><em>8. Examine the DNS response message. How many “answers” are provided? What  do each of these answers contain?</em></p><p><em>下面这个例子中，答案数为1，其内容如图。</em></p><p><img src="/2022/12/29/CNLab7-1/image-20221203060550658.png" alt="image-20221203060550658"></p><p><em>9. Consider the subsequent TCP SYN packet sent by your host. Does the destination IP address of the SYN packet correspond to any of the IP addresses provided in the DNS response message?</em> </p><p><em>如下图可知，二者相对应。</em></p><p><img src="/2022/12/29/CNLab7-1/image-20221203061017800.png" alt="image-20221203061017800"></p><p><em>10. This web page contains images. Before retrieving each image, does your host issue new DNS queries?</em> </p><p><em>发起了新的查询，原因可能是图片存放的服务器的域名和之前查询的不一致。</em></p><p>现在我们来练习使用nslookup。首先，先在命令行运行”ipconfig &#x2F;flushdns”以清除缓存。在打开Wireshark开始抓包后，在命令行中输入”nslookup on <a href="http://www.mit.edu"./">www.mit.edu&quot;。</a></p><p><img src="/2022/12/29/CNLab7-1/image-20221203062325456.png" alt="image-20221203062325456"></p><p>运行完成后停止抓包，得到结果如下图。</p><p><img src="/2022/12/29/CNLab7-1/image-20221203062555017.png" alt="image-20221203062555017"></p><p><em>11. What is the destination port for the DNS query message? What is the source port  of DNS response message?</em> </p><p><em>由下面两图可知，与之前一样，DNS查询消息的目的端口和DNS响应消息的源端口都为53。</em></p><p><img src="/2022/12/29/CNLab7-1/image-20221203062736314.png" alt="image-20221203062736314"></p><p><img src="/2022/12/29/CNLab7-1/image-20221203062834172.png" alt="image-20221203062834172"></p><p><em>12. To what IP address is the DNS query message sent? Is this the IP address of your default local DNS server?</em> </p><p><em>由下图可知，DNS 查询消息发送到的IP地址为192.168.254.245，这与我们之前得到的本地DNS服务器的IP地址相同。</em></p><p><img src="/2022/12/29/CNLab7-1/image-20221203062950094.png" alt="image-20221203062950094"></p><p><em>13. Examine the DNS query message. What “Type” of DNS query is it? Does the  query message contain any “answers”?</em> </p><p><em>如下图，为A类型（也有AAAA类型），没有答案。</em></p><p><img src="/2022/12/29/CNLab7-1/image-20221203063129764.png" alt="image-20221203063129764"></p><p><em>14. Examine the DNS response message. How many “answers” are provided? What do each of these answers contain?</em> </p><p><em>如下图，答案数为3，内容如图。</em></p><p><img src="/2022/12/29/CNLab7-1/image-20221203063254661.png" alt="image-20221203063254661"></p><p><em>15. Provide a screenshot.</em></p><p><em>上面每个问题的回答都带有截图。</em></p><p>现在重复刚刚的实验，不过把命令换为”nslookup –type&#x3D;NS mit.edu”。抓包结果如下。</p><p><img src="/2022/12/29/CNLab7-1/image-20221203064325190.png" alt="image-20221203064325190"></p><p><em>16. To what IP address is the DNS query message sent? Is this the IP address of your default local DNS server?</em> </p><p><em>由下图可知，DNS 查询消息发送到的IP地址为192.168.254.245，这与我们之前得到的本地DNS服务器的IP地址相同。</em></p><p><img src="/2022/12/29/CNLab7-1/image-20221203064401955.png" alt="image-20221203064401955"></p><p><em>17. Examine the DNS query message. What “Type” of DNS query is it? Does the  query message contain any “answers”?</em> </p><p><em>如下图，为NS类型，没有答案。</em></p><p><img src="/2022/12/29/CNLab7-1/image-20221203064459497.png" alt="image-20221203064459497"></p><p><em>18. Examine the DNS response message. What MIT nameservers does the response message provide? Does this response message also provide the IP addresses of the MIT namesers?</em> </p><p><em>如图，提供了麻省理工学院的一系列nameserver。经比对可发现，响应消息里不包含麻省理工学院的IP地址。</em></p><p><img src="/2022/12/29/CNLab7-1/image-20221203064921225.png" alt="image-20221203064921225"></p><p><em>19. Provide a screenshot.</em></p><p><em>上面每个问题的回答都带有截图。</em></p><p>再次重复刚刚的实验，不过把命令换为”nslookup <a href="http://www.google.com/">www.google.com</a> bitsy.mit.edu”（这里实验手册给出的命令为”nslookup <a href="http://www.aiit.or.kr/">www.aiit.or.kr</a> bitsy.mit.edu”，但一直超时（如下图），试了下最后发现改成谷歌可以）。</p><p><img src="/2022/12/29/CNLab7-1/image-20221203065543303.png" alt="image-20221203065543303"></p><p>抓包结果如下。</p><p><img src="/2022/12/29/CNLab7-1/image-20221203065758030.png" alt="image-20221203065758030"></p><p><em>20. To what IP address is the DNS query message sent? Is this the IP address of your  default local DNS server? If not, what does the IP address correspond to?</em> </p><p><em>由下图可知，DNS 查询消息发送到的IP地址为18.0.72.3，这与我们之前得到的本地DNS服务器的IP地址不同，它对应的是bitsy.mit.edu。</em></p><p><img src="/2022/12/29/CNLab7-1/image-20221203070205462.png" alt="image-20221203070205462"></p><p><em>21. Examine the DNS query message. What “Type” of DNS query is it? Does the  query message contain any “answers”?</em> </p><p><em>如下图，为A类型（也有AAAA类型），没有答案。</em></p><p><img src="/2022/12/29/CNLab7-1/image-20221203070256432.png" alt="image-20221203070256432"></p><p><em>22. Examine the DNS response message. How many “answers” are provided? What  does each of these answers contain?</em> </p><p><em>如下图，答案数为1，内容如图。</em></p><p><img src="/2022/12/29/CNLab7-1/image-20221203070404563.png" alt="image-20221203070404563"></p><p><em>23. Provide a screenshot.</em></p><p><em>上面每个问题的回答都带有截图。</em></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lab6-2 Wireshark-UDP</title>
      <link href="/2022/12/29/CNLab6-2/"/>
      <url>/2022/12/29/CNLab6-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Lab6-2-UDP"><a href="#Lab6-2-UDP" class="headerlink" title="Lab6-2 UDP"></a>Lab6-2 UDP</h2><h4 id="1-Objective"><a href="#1-Objective" class="headerlink" title="1 Objective"></a>1 Objective</h4><p>查看UDP(用户数据报协议)的详细信息。UDP是在Internet上使用的一种传输协议，在不需要可靠性时作为TCP的替代方案。</p><h4 id="2-Steps"><a href="#2-Steps" class="headerlink" title="2 Steps"></a>2 Steps</h4><h5 id="Step-1-Capture-a-Trace"><a href="#Step-1-Capture-a-Trace" class="headerlink" title="Step 1: Capture a Trace"></a>Step 1: Capture a Trace</h5><p>跟上个实验一样，实验手册中提供了本实验的抓包结果，可以直接点击<a href="https://kevincurran.org/com320/labs/wireshark/trace-udp.pcap">链接</a>下载。</p><p><img src="/2022/12/29/CNLab6-2/image-20221202220817270.png" alt="image-20221202220817270"></p><h5 id="Step-2-Inspect-the-Trace"><a href="#Step-2-Inspect-the-Trace" class="headerlink" title="Step 2: Inspect the Trace"></a>Step 2: Inspect the Trace</h5><p>任选一个协议列为DNS的从服务端下载到本机的长数据包，查看其UDP协议层的详细信息。</p><p><img src="/2022/12/29/CNLab6-2/image-20221202220919216.png" alt="image-20221202220919216"></p><p>我们可以看到以下字段（我们只讨论通过网络传输的字段）：</p><ul><li>“Source Port”和”Destination Port”分别是UDP消息发送的端口号和UDP消息目的地的端口号。端口是UDP中唯一的寻址形式。</li><li>“Length”给出了UDP消息的长度。</li><li>“Checksum”是用于验证消息内容的消息校验和。</li></ul><h5 id="Step-3-UDP-Message-Structure"><a href="#Step-3-UDP-Message-Structure" class="headerlink" title="Step 3: UDP Message Structure"></a>Step 3: UDP Message Structure</h5><table><thead><tr><th>IP header</th><th>Source Port</th><th>Destination Port</th><th>Length</th><th>Checksum</th><th>UDP payload</th></tr></thead><tbody><tr><td></td><td>2 bytes</td><td>2 bytes</td><td>2 bytes</td><td>2 bytes</td><td></td></tr><tr><td></td><td>UDP header(8 bytes)</td><td>~</td><td>~</td><td>~</td><td></td></tr></tbody></table><p><em>1. What does the Length field include? The UDP payload, UDP payload and UDP header, or UDP  payload, UDP header, and lower layer headers?</em></p><p>Length字段给出了UDP有效负载字节加上UDP报头的长度。</p><p><em>2. How long in bits is the UDP checksum?</em> </p><p>校验和是16位长。</p><p><em>3. How long in bytes is the entire UDP header?</em></p><p>UDP头长度为8字节。</p><h5 id="Step-4-UDP-Usage"><a href="#Step-4-UDP-Usage" class="headerlink" title="Step 4: UDP Usage"></a>Step 4: UDP Usage</h5><p>为了加深我们对UDP的理解，我们将看看UDP在应用程序中作为一种传输协议是如何被实际使用的。</p><p>我们可以考虑几个问题，第一个问题是IP如何知道下一个更高的协议层是UDP，答案是在IP报头中有一个Protocol字段，它包含这个信息。</p><p><em>Q: Give the value of the IP Protocol field that identifies the upper layer protocol as UDP.</em></p><p><em>A：如下图，“IP Protocol”字段值为17表示UDP。</em></p><p><img src="/2022/12/29/CNLab6-2/image-20221202223719259.png" alt="image-20221202223719259"></p><p>第二个问题是UDP消息通常如何在IP层寻址。我们可以发现一个神奇的事情，就是UDP消息既不来自于本地计算机，也不是只发送到本地计算机，我们可以通过对Source和Destination列进行排序来查看这一点。这种情况的原因是UDP被广泛用作系统协议的一部分，这些协议经常使用广播和多播地址向所有对它们感兴趣的本地计算机发送消息。</p><p><em>Q: Examine the UDP messages and give the destination IP addresses that are used when your computer is neither the source IP address nor the destination IP address. (If you have only your computer as the source or destination IP address then you may use the supplied trace.)</em></p><p><em>A：如下图，此时目标IP地址为239.255.255.250。</em></p><p><img src="/2022/12/29/CNLab6-2/image-20221202224327032.png" alt="image-20221202224327032"></p><p><em>Q: What is the typical size of UDP messages in your trace?</em></p><p><em>我们依次查看各个数据包的UDP信息长度可以发现，这个答案会随着追踪变化。它们通常在100~200个字节之间。</em></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lab6-1 Wireshark-TCP</title>
      <link href="/2022/12/29/CNLab6-1/"/>
      <url>/2022/12/29/CNLab6-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Lab6-1-TCP"><a href="#Lab6-1-TCP" class="headerlink" title="Lab6-1 TCP"></a>Lab6-1 TCP</h2><h4 id="1-Objective"><a href="#1-Objective" class="headerlink" title="1 Objective"></a>1 Objective</h4><p>查看TCP(传输控制协议)的详细信息。</p><h4 id="2-Requirements"><a href="#2-Requirements" class="headerlink" title="2 Requirements"></a>2 Requirements</h4><p>本实验要求使用Wireshark软件、wget程序和任意的web浏览器。</p><h4 id="3-Steps"><a href="#3-Steps" class="headerlink" title="3 Steps"></a>3 Steps</h4><h5 id="Step-1-Capture-a-Trace"><a href="#Step-1-Capture-a-Trace" class="headerlink" title="Step 1: Capture a Trace"></a>Step 1: Capture a Trace</h5><p>实验手册中提供了本实验的抓包结果，可以直接点击<a href="https://kevincurran.org/com320/labs/wireshark/trace-tcp.pcap">链接</a>下载（学校官网的链接无法下载，在凯文教授主页找到了可以下载的链接）。</p><p><img src="/2022/12/29/CNLab6-1/image-20221202194107359.png" alt="image-20221202194107359"></p><h5 id="Step-2-Inspect-the-Trace"><a href="#Step-2-Inspect-the-Trace" class="headerlink" title="Step 2: Inspect the Trace"></a>Step 2: Inspect the Trace</h5><p>任选一个协议列为TCP的从服务端下载到本机的长数据包，查看其TCP协议层的详细信息。</p><p><img src="/2022/12/29/CNLab6-1/image-20221202195842295.png" alt="image-20221202195842295"></p><p>我们可以看到以下字段（我们只讨论通过网络传输的字段）：</p><ul><li>“Source Port”和”Destination Port”是TCP在IP地址之外添加的寻址。”Source Port”即源端口号很可能是80（这里也的确是80），这是因为数据包由web服务器发送，而标准的web服务器端口是80。</li><li>“Sequence Number”给出了第一个有效负载字节在字节流中的位置。</li><li>“Acknowledgment Number”给出了反向字节流中最后接受到的位置。</li><li>“Header Length”给出了TCP报头的长度。</li><li>“Flags”字段有多个标志位来表示TCP段的类型。</li><li>“Checksum”用于检测传输错误。</li><li>“Options”字段提供了一系列选项。</li><li>“TCP payload”字段存储了被传输的字节。</li></ul><h5 id="Step-3-TCP-Segment-Structure"><a href="#Step-3-TCP-Segment-Structure" class="headerlink" title="Step 3: TCP Segment Structure"></a>Step 3: TCP Segment Structure</h5><table><thead><tr><th>Source Port</th><th>Destination Port</th><th>Sequence number</th><th>Ack number</th><th>Header length</th><th>Flags</th><th>Check sum</th><th>Window size</th><th>Urgent pointer</th><th>Options</th><th>Payload</th></tr></thead><tbody><tr><td>2 bytes</td><td>2 bytes</td><td>4 bytes</td><td>4 bytes</td><td>(2</td><td>bytes)</td><td>2 bytes</td><td>2 bytes</td><td>2 bytes</td><td>variable</td><td>N bytes</td></tr><tr><td>TCP header</td><td>~</td><td>~</td><td>~</td><td>~</td><td>~</td><td>~</td><td>~</td><td>~</td><td>~</td><td>TCP payload</td></tr></tbody></table><h5 id="Step-4-TCP-Connection-Setup-x2F-Teardown"><a href="#Step-4-TCP-Connection-Setup-x2F-Teardown" class="headerlink" title="Step 4: TCP Connection Setup&#x2F;Teardown"></a>Step 4: TCP Connection Setup&#x2F;Teardown</h5><p>要查看“三次握手”的运行情况，请查找带有SYN标志的TCP段以及它后面的包，也可以使用过滤器表达式“tcp.flags.syn&#x3D;&#x3D;1”来搜索带有SYN标志的数据包。</p><p><img src="/2022/12/29/CNLab6-1/image-20221202201920364.png" alt="image-20221202201920364"></p><p>“SYN”包是三次握手的开始。在它被从本机发送到远程服务器后，远程服务器应该返回一个“SYN,ACK”包。在接收到这个包后，本地计算机将对其进行确认并开始发送数据。</p><p><em>Draw a time sequence diagram of the three-way handshake in your trace, up to and including the first  data packet (the HTTP GET request) sent by your computer when the connection is established Put your  computer on the left side and the remote server on the right side. As usual, time runs down the page,  and lines across the page indicate segments.</em> </p><p><em>Include the following features on your diagram:</em> </p><ul><li><em>The Sequence and ACK number, if present, on each segment. The ACK number is only carried if  the segment has the ACK flag set.</em> </li><li><em>The time in milliseconds, starting at zero, each segment was sent or received at your computer.</em> </li><li><em>The round-trip time to the server estimated as the difference between the SYN and SYN-ACK  segments.</em></li></ul><p><img src="/2022/12/29/CNLab6-1/image-20221202202219889.png" alt="image-20221202202219889"></p><p>“SYN”包和”SYN,ACK”包及后续包（直至并包括连接建立时计算机发送的第一个数据包(HTTP GET请求)）如上图，参考上图可以画出三次握手的时间序列图。</p><p><img src="/2022/12/29/CNLab6-1/image-20221202205820368.png" alt="image-20221202205820368"></p><h5 id="Step-5-Connection-Options"><a href="#Step-5-Connection-Options" class="headerlink" title="Step 5: Connection Options"></a>Step 5: Connection Options</h5><p>除了建立连接之外，TCP “SYN”包还使用选项在两端之间协商参数。每一端通过在其SYN上包含适当的选项向另一端描述其能力(如果有的话)，通常两端都必须支持在数据传输过程中用到的行为。</p><p><em>What TCP Options are carried on the SYN packets for your trace?</em></p><p>如下图。</p><p><img src="/2022/12/29/CNLab6-1/image-20221202204643312.png" alt="image-20221202204643312"></p><h5 id="Step-6-FIN-x2F-RST-Teardown"><a href="#Step-6-FIN-x2F-RST-Teardown" class="headerlink" title="Step 6: FIN&#x2F;RST Teardown"></a>Step 6: FIN&#x2F;RST Teardown</h5><p>最后，TCP连接在下载完成后关闭，这通常通过FIN (Finalize)段来完成。每一方发送一个FIN给另一方，并确认他们收到的FIN，这有点类似于三次握手。或者，当一端发送RST (Reset)时，连接可能突然断开，这个数据包不需要被对方确认。</p><p><em>Draw a picture of the teardown in your trace, starting from when the first FIN or RST is issued until the  connection is complete. As before, show the sequence and ACK numbers on each segment. If you have  FINs then use the time difference to estimate the round-trip time.</em></p><p><img src="/2022/12/29/CNLab6-1/image-20221202205315973.png" alt="image-20221202205315973"></p><p>参考上图，可以画出时间序列图。</p><p><img src="/2022/12/29/CNLab6-1/image-20221202210117925.png" alt="image-20221202210117925"></p><h5 id="Step-7-TCP-Data-Transfer"><a href="#Step-7-TCP-Data-Transfer" class="headerlink" title="Step 7: TCP Data Transfer"></a>Step 7: TCP Data Transfer</h5><p>在”统计“栏中选择”I&#x2F;O图表“，然后点击左下角”+”添加新图形，并修改”Display Filter”值分别为”tcp.srcport&#x3D;&#x3D;80”和”tcp.dstport=&#x3D;80”，得到下面的图表。</p><p><img src="/2022/12/29/CNLab6-1/image-20221202212100606.png" alt="image-20221202212100606"></p><p><em>1. What is the rough data rate in the download direction in packets&#x2F;second and bits&#x2F;second once  the TCP connection is running well?</em></p><p>以包&#x2F;秒的单位的速率可以参考上图，可以看出速率约为225 包&#x2F;秒；以位&#x2F;秒的单位的速率可以参考下图，可以看出速率约为$2.5×10^6$ 位&#x2F;秒。</p><p><img src="/2022/12/29/CNLab6-1/image-20221202213527791.png" alt="image-20221202213527791"></p><p><em>2. What percentage of this download rate is content? Show your calculation. To find out, look at a  typical download packet; there should be many similar, large download packets. You can see  how long it is, and how many bytes of TCP payload it contains.</em></p><p>由下图可知，下载总量为1434 bytes，其中有效负载总量为1368 bytes，比例约为95.40%（1368&#x2F;1434≈0.95397）。</p><p><img src="/2022/12/29/CNLab6-1/image-20221202213924589.png" alt="image-20221202213924589"></p><p><em>3. What is the rough data rate in the upload direction in packets&#x2F;second and bits&#x2F;second due to the  ACK packets?</em></p><p>以包&#x2F;秒为单位的数据可以从第一张I&#x2F;O图中读到，可以看到约为110 包&#x2F;秒；以位&#x2F;秒为单位的数据可以从下图中读到，可以看到约为42000 位&#x2F;秒。</p><p><img src="/2022/12/29/CNLab6-1/image-20221202214215309.png" alt="image-20221202214215309"></p><p><em>4. If the most recently received TCP segment from the server has a sequence number of X, then  what ACK number does the next transmitted TCP segment carry?</em></p><p>X加上数据段中的TCP有效负载字节数。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lab5-2 Wireshark_ICMP</title>
      <link href="/2022/12/29/CNLab5-2/"/>
      <url>/2022/12/29/CNLab5-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Lab5-2-ICMP"><a href="#Lab5-2-ICMP" class="headerlink" title="Lab5-2 ICMP"></a>Lab5-2 ICMP</h2><h4 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h4><p>在这个实验中，我们将探索ICMP协议。</p><h4 id="2-Steps"><a href="#2-Steps" class="headerlink" title="2 Steps"></a>2 Steps</h4><h5 id="Step-1-ICMP-and-Ping"><a href="#Step-1-ICMP-and-Ping" class="headerlink" title="Step 1: ICMP and Ping"></a>Step 1: ICMP and Ping</h5><p>让我们从捕获Ping程序生成的数据包开始。首先使用Wireshark开始抓包（使用icmp过滤器），然后在命令行中输入”ping -n 10 <a href="http://www.ust.hk",待ping程序运行结束后停止抓包./">www.ust.hk&quot;，待ping程序运行结束后停止抓包。</a></p><p><img src="/2022/12/29/CNLab5-2/image-20221202071122623.png" alt="image-20221202071122623"></p><p>得到如下结果：</p><p><img src="/2022/12/29/CNLab5-2/image-20221202071452425.png" alt="image-20221202071452425"></p><p><em>1. What is the IP address of your host? What is the IP address of the destination host?</em>  </p><p>由下图可知，本机IP为172.25.145.196，目标主机IP为143.89.12.134。</p><p><img src="/2022/12/29/CNLab5-2/image-20221202071856801.png" alt="image-20221202071856801"></p><p><em>2. Why is it that an ICMP packet does not have source and destination port numbers?</em> </p><p>因为ICMP是网络层的协议，它不需要传输层TCP或者UDP的承载，直接使用IP数据报承载，因此不需要源端口号和目的端口号，只要源地址和目的地址即可。</p><p><em>3. Examine one of the ping request packets sent by your host. What are the ICMP type and code numbers? What other fields does this ICMP packet have? How many bytes are the checksum, sequence number and identifier fields?</em> </p><p>由下图可知，Type值为8，Code值为0。这个ICMP包中还有校验和、标识符和序列号，各自占了两字节。</p><p><img src="/2022/12/29/CNLab5-2/image-20221202072558910.png" alt="image-20221202072558910"></p><p><img src="/2022/12/29/CNLab5-2/image-20221202073132868.png" alt="image-20221202073132868"></p><p><img src="/2022/12/29/CNLab5-2/image-20221202073142828.png" alt="image-20221202073142828"></p><p><img src="/2022/12/29/CNLab5-2/image-20221202073148033.png" alt="image-20221202073148033"></p><p><img src="/2022/12/29/CNLab5-2/image-20221202073153547.png" alt="image-20221202073153547"></p><p><img src="/2022/12/29/CNLab5-2/image-20221202073159674.png" alt="image-20221202073159674"></p><p><em>4. Examine the corresponding ping reply packet. What are the ICMP type and code  numbers? What other fields does this ICMP packet have? How many bytes are the  checksum, sequence number and identifier fields?</em></p><p>由下图可知，Type值为0，Code值为0。这个ICMP包中还有校验和、标识符、序列号和响应时间，各自占了两字节。</p><p><img src="/2022/12/29/CNLab5-2/image-20221202073421963.png" alt="image-20221202073421963"></p><p><img src="/2022/12/29/CNLab5-2/image-20221202073433230.png" alt="image-20221202073433230"></p><p><img src="/2022/12/29/CNLab5-2/image-20221202073438678.png" alt="image-20221202073438678"></p><p><img src="/2022/12/29/CNLab5-2/image-20221202073443351.png" alt="image-20221202073443351"></p><p><img src="/2022/12/29/CNLab5-2/image-20221202073448465.png" alt="image-20221202073448465"></p><p><img src="/2022/12/29/CNLab5-2/image-20221202073459907.png" alt="image-20221202073459907"></p><h5 id="Step-2-ICMP-and-Traceroute"><a href="#Step-2-ICMP-and-Traceroute" class="headerlink" title="Step 2: ICMP and Traceroute"></a>Step 2: ICMP and Traceroute</h5><p>使用Wireshark开始抓包（使用icmp过滤器），然后在命令行中输入”tracert <a href="http://www.inria.fr",待程序运行结束后停止抓包./">www.inria.fr&quot;，待程序运行结束后停止抓包。</a></p><p><img src="/2022/12/29/CNLab5-2/image-20221202075312551.png" alt="image-20221202075312551"></p><p>得到如下结果：</p><p><img src="/2022/12/29/CNLab5-2/image-20221202075413742.png" alt="image-20221202075413742"></p><p><em>5. What is the IP address of your host? What is the IP address of the target  destination host?</em>  </p><p>由下图可知，本机IP为172.25.145.196，目标主机IP为128.93.162.83。</p><p><img src="/2022/12/29/CNLab5-2/image-20221202075943982.png" alt="image-20221202075943982"></p><p><em>6. If ICMP sent UDP packets instead (as in Unix&#x2F;Linux), would the IP protocol number still be 01 for the probe packets? If not, what would it be?</em> </p><p>这里没有抓取到UDP包，查阅资料得知此时数据包的IP协议号不是 01，是17。</p><p><em>7. Examine the ICMP echo packet in your screenshot. Is this different from the ICMP ping query packets in the first half of this lab? If yes, how so?</em> </p><p>不同，前半部分的ping查询数据包中ICMP报文类型为11，表示数据报过期需要丢弃，返回此ICMP报文警告源主机。</p><p><img src="/2022/12/29/CNLab5-2/image-20221202081111481.png" alt="image-20221202081111481"></p><p><em>8. Examine the ICMP error packet in your screenshot. It has more fields than the  ICMP echo packet. What is included in those fields?</em> </p><p>由对比可知，错误的数据包多了请求数据包内容。</p><p><img src="/2022/12/29/CNLab5-2/image-20221202082019225.png" alt="image-20221202082019225"></p><p><img src="/2022/12/29/CNLab5-2/image-20221202081811394.png" alt="image-20221202081811394"></p><p><em>9. Examine the last three ICMP packets received by the source host. How are these  packets different from the ICMP error packets? Why are they different?</em> </p><p>区别如上题所述，最后三个包正常收到了回复（感觉这里我抓包有问题，搜了搜看了下一些博主做的实验，发现他们有收到我没有收到的icmp包——Type值为3且标注了端点不可达）。</p><p><em>10. Within the tracert measurements, is there a link whose delay is significantly  longer than others? Refer to the screenshot in Figure 4, is there a link whose  delay is significantly longer than others? On the basis of the router names, can  you guess the location of the two routers on the end of this link?</em></p><p>由下图我们可以发现从第16次请求开始，花费时间一下子增长了很多。</p><p><img src="/2022/12/29/CNLab5-2/image-20221202075312551.png" alt="image-20221202075312551"></p><p>使用<a href="https://ip.cn/ip/62.40.124.204.html">IP 地址查询</a>查询该IP可以发现其所在地理位置为英国。一直到第19个请求，IP所在的地理位置都为英国。</p><p><img src="/2022/12/29/CNLab5-2/image-20221202083551548.png" alt="image-20221202083551548"></p><p>从第20个请求起的后续IP及目标主机IP所在的地理位置均在法国。</p><p><img src="/2022/12/29/CNLab5-2/image-20221202083815921.png" alt="image-20221202083815921"></p><p><img src="/2022/12/29/CNLab5-2/image-20221202083924132.png" alt="image-20221202083924132"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lab5-1 Wireshark-ipv4</title>
      <link href="/2022/12/29/CNLab5-1/"/>
      <url>/2022/12/29/CNLab5-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Lab5-1-IPv4"><a href="#Lab5-1-IPv4" class="headerlink" title="Lab5-1 IPv4"></a>Lab5-1 IPv4</h2><h4 id="1-Objective"><a href="#1-Objective" class="headerlink" title="1 Objective"></a>1 Objective</h4><p>了解IP (Internet Protocol)的详细信息。</p><h4 id="2-Requirements"><a href="#2-Requirements" class="headerlink" title="2 Requirements"></a>2 Requirements</h4><p>除Wireshark外，本实验要求使用wget和traceroute&#x2F;tracert程序。</p><h4 id="3-Steps"><a href="#3-Steps" class="headerlink" title="3 Steps"></a>3 Steps</h4><h5 id="Step-1-Capture-a-Trace"><a href="#Step-1-Capture-a-Trace" class="headerlink" title="Step 1: Capture a Trace"></a>Step 1: Capture a Trace</h5><ol><li><p>在远程服务器上选择一个URL，并使用wget获取内容，例如“wget <a href="https://www.uwa.edu.au/%E2%80%9D%E3%80%82">https://www.uwa.edu.au/”。</a></p><p><img src="/2022/12/29/CNLab5-1/image-20221202000104434.png" alt="image-20221202000104434"></p></li><li><p>执行到同一远程服务器的traceroute，以检查是否可以发现有关网络路径的信息。在Windows下执行“tracert <a href="http://www.uwa.edu.au”./">www.uwa.edu.au”。</a></p><p><img src="/2022/12/29/CNLab5-1/image-20221202001107868.png" alt="image-20221202001107868"></p></li><li><p>启动Wireshark并使用“tcp port 80”的过滤器开始捕获。确保勾选”enable network name resolution”。</p><p><img src="/2022/12/29/CNLab5-1/image-20221202001438461.png" alt="image-20221202001438461"></p></li><li><p>在启动捕获之后，重复上面的wget命令，数据包就会被Wireshark记录下来。</p></li><li><p>命令执行完毕后，返回Wireshark，我们可以看到结果如下。</p><p><img src="/2022/12/29/CNLab5-1/image-20221202002421546.png" alt="image-20221202002421546"></p></li></ol><h5 id="Step-2-Inspect-the-Trace"><a href="#Step-2-Inspect-the-Trace" class="headerlink" title="Step 2: Inspect the Trace"></a>Step 2: Inspect the Trace</h5><p>选中任意一个数据包，查看它的IP报头的详细信息。</p><p><img src="/2022/12/29/CNLab5-1/image-20221202002650580.png" alt="image-20221202002650580"></p><ul><li><p>“Version”为4，是”IPv4”的缘故。</p><p><img src="/2022/12/29/CNLab5-1/image-20221202003359244.png" alt="image-20221202003359244"></p></li><li><p>“Header Length”描述了标题长度（可以发现”Version”和”Header Length”字段被打包进了一个字节中）。</p><p><img src="/2022/12/29/CNLab5-1/image-20221202003406998.png" alt="image-20221202003406998"></p></li><li><p>“Differentiated Services Field”包含位标识，用来指示是否应该在路由器上以服务质量和拥塞指示来处理包。</p><p><img src="/2022/12/29/CNLab5-1/image-20221202003329063.png" alt="image-20221202003329063"></p></li><li><p>“Total Length”字段顾名思义，描述了这部分信息的总长度。</p></li><li><p>“Identification”字段用于在一个大的IP包作为多个称为片段的小片段发送时对片段进行分组。</p></li><li><p>“Flags”和”Fragment Offset”字段，他们紧随”Identification”其后，也与片段有关。</p><p><img src="/2022/12/29/CNLab5-1/image-20221202004037604.png" alt="image-20221202004037604"></p></li><li><p>“Time to Live（TTL）”和”Protocol”字段分别描述了持续时间和数据协议类型。</p></li><li><p>“Header Checksum”用来确保信息传输过程中的正确性，若校验和验证不正确，则会在丢弃掉对应的错误报文后再进行后续操作。</p></li><li><p>“Source Address”和”Destination Address”描述了源地址和目标地址。</p></li></ul><h5 id="Step-3-IP-Packet-Structure"><a href="#Step-3-IP-Packet-Structure" class="headerlink" title="Step 3: IP Packet Structure"></a>Step 3: IP Packet Structure</h5><p>用如下结构即可回答问题。</p><p><img src="/2022/12/29/CNLab5-1/image-20221202004922050.png" alt="image-20221202004922050"></p><p><em>1. What are the IP addresses of your computer and the remote server?</em></p><p>本机IP：111.31.200.210；远程IP：172.25.145.196。</p><p><em>2. Does the Total Length field include the IP header plus IP payload, or just the IP payload?</em> </p><p>只包括IP payload。</p><p><em>3. How does the value of the Identification field change or stay the same for different packets? For  instance, does it hold the same value for all packets in a TCP connection or does it differ for each  packet? Is it the same in both directions? Can you see any pattern if the value does change?</em></p><p>一个连接中所有的包 Identification 都不相同，在不同方向上也不相同，在同一方向上每产生一个数据包会自增 1。</p><p><img src="/2022/12/29/CNLab5-1/image-20221202010501507.png" alt="image-20221202010501507"></p><p><img src="/2022/12/29/CNLab5-1/image-20221202010511233.png" alt="image-20221202010511233"></p><p><em>4. What is the initial value of the TTL field for packets sent from your computer? Is it the maximum  possible value, or some lower value?</em> </p><p>128，不是最大值。</p><p><img src="/2022/12/29/CNLab5-1/image-20221202010627509.png" alt="image-20221202010627509"></p><p><em>5. How can you tell from looking at a packet that it has not been fragmented? Most often IP packets in normal operation are not fragmented. But the receiver must have a way to be sure. Hint:  you may need to read your text to confirm a guess.</em> </p><p>如图，设置了”Don’t fragment”。</p><p><img src="/2022/12/29/CNLab5-1/image-20221202010758745.png" alt="image-20221202010758745"></p><p><em>6. What is the length of the IP Header and how is this encoded in the header length field? Hint: notice that only 4 bits are used for this field, as the version takes up the other 4 bits of the byte. You may guess and check your text.</em></p><p>如图即可得知长度为20 bytes，编码为0x45。</p><p><img src="/2022/12/29/CNLab5-1/image-20221202011016220.png" alt="image-20221202011016220"></p><h5 id="Step-4-Internet-Paths"><a href="#Step-4-Internet-Paths" class="headerlink" title="Step 4: Internet Paths"></a>Step 4: Internet Paths</h5><p>tracert输出通常打印每行一跳的信息，包括测量的往返时间和路由器的IP地址和DNS名称。DNS名称便于确定路由器所属的组织。由于tracert利用了通用路由器实现，所以不能保证它对路径上的所有路由器都有效，当它对路径的某些部分失败时，通常会看到“*”响应。</p><p><img src="/2022/12/29/CNLab5-1/image-20221202001107868.png" alt="image-20221202001107868"></p><h5 id="Step-5-IP-Header-Checksum"><a href="#Step-5-IP-Header-Checksum" class="headerlink" title="Step 5: IP Header Checksum"></a>Step 5: IP Header Checksum</h5><p>我们可以通过验证包来探究IP报头校验和计算。首先，选择一个IP报头为20字节的包（这是没有选项时的最小报头大小，可以使这个练习更容易），然后按照以下步骤检查校验和值是否正确：</p><p><img src="/2022/12/29/CNLab5-1/image-20221202063248656.png" alt="image-20221202063248656"></p><ol><li><p>将内容分成10个两个字节(16位)的单词。每个单词将是4个十六进制数字，如这里的第一个单词是”45 00”。</p></li><li><p>使用常规加法将这10个单词相加。这里经加和后得到结果为4486b。</p></li><li><p>从结果中计算1s的补和，取任何前导数字(大于单词大小的4位数)并将它们加回到余数中。如在这里，4486b将变为486b+4&#x3D;486f。</p></li><li><p>最终的结果若为Oxffff，则说明验证为正确。这里我们得到的结果为0x486f，不是0xffff，说明验证为不正确。我们可以通过Wireshark来验证我们的计算结果：</p><ol><li><p>在”编辑-首选项-Protocols”中找到IPv4项并打开。</p></li><li><p>勾选”Validate the IPv4 checksum if possible”。</p><p><img src="/2022/12/29/CNLab5-1/image-20221202064645772.png" alt="image-20221202064645772"></p></li><li><p>可以看到，刚刚选中的数据包的校验和果然是错误的。</p><p><img src="/2022/12/29/CNLab5-1/image-20221202064841190.png" alt="image-20221202064841190"></p></li></ol></li><li><p>（为了有一次验证正确的经历）我们可以重新选一个包来计算，如Wireshark已显示校验和正确的21号包。我们划分单词后可以求得其和为3fffc，将进位加到低位得：fffc+3&#x3D;ffff，即最后得到的结果为0xffff，验证正确。</p><p><img src="/2022/12/29/CNLab5-1/image-20221202065220331.png" alt="image-20221202065220331"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lab4-2 Wireshark-80211</title>
      <link href="/2022/12/29/CNLab4-2/"/>
      <url>/2022/12/29/CNLab4-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Lab4-2-802-11"><a href="#Lab4-2-802-11" class="headerlink" title="Lab4-2 802.11"></a>Lab4-2 802.11</h2><h4 id="1-Objective"><a href="#1-Objective" class="headerlink" title="1 Objective"></a>1 Objective</h4><p>探究802.11的物理层、链路层和管理功能。</p><h4 id="2-Requirements"><a href="#2-Requirements" class="headerlink" title="2 Requirements"></a>2 Requirements</h4><p>Wireshark软件。</p><h4 id="3-Steps"><a href="#3-Steps" class="headerlink" title="3 Steps"></a>3 Steps</h4><h5 id="Step-1-Fetch-a-Trace"><a href="#Step-1-Fetch-a-Trace" class="headerlink" title="Step 1: Fetch a Trace"></a>Step 1: Fetch a Trace</h5><p>直接打开附件里的”trace-80211.pcap”来进行探究。</p><p><img src="/2022/12/29/CNLab4-2/image-20221130225233978.png" alt="image-20221130225233978"></p><h5 id="Step-2-Inspect-the-Trace"><a href="#Step-2-Inspect-the-Trace" class="headerlink" title="Step 2: Inspect the Trace"></a>Step 2: Inspect the Trace</h5><p>首先，我们将研究802.11帧的格式。如下图，有许多不同种类的802.11帧被捕获在了追踪中，我们可以通过info字段来分辨他们的类型，如Beacon、Data和Acknowledgement。</p><p><img src="/2022/12/29/CNLab4-2/image-20221130225721909.png" alt="image-20221130225721909"></p><p>我们选中一个数据帧进行查看：</p><p><img src="/2022/12/29/CNLab4-2/image-20221130230045230.png" alt="image-20221130230045230"></p><ul><li><p>“Frame”是由Wireshark添加的记录，包含了帧的时间和长度信息等。</p><p><img src="/2022/12/29/CNLab4-2/image-20221130231545659.png" alt="image-20221130231545659"></p></li><li><p>“Radiotap”也是Wireshark添加的记录，用于捕获物理层参数，如信号的强度和调制。</p><p><img src="/2022/12/29/CNLab4-2/image-20221130231602103.png" alt="image-20221130231602103"></p></li><li><p>“IEEE 802.11”是802.11数据帧的位。</p><p><img src="/2022/12/29/CNLab4-2/image-20221130231613913.png" alt="image-20221130231613913"></p></li><li><p>“Data”是包含帧有效载荷数据的记录，即具有诸如LLC、IP包等更高层协议的数据。或者，可以看到更高层的协议本身。</p><p><img src="/2022/12/29/CNLab4-2/image-20221130231636337.png" alt="image-20221130231636337"></p></li></ul><p>接下来我们将重点探究”IEEE 802.11”中的内容。</p><ul><li><p>“Frame Control”编码帧的类型和子类型。</p><p><img src="/2022/12/29/CNLab4-2/image-20221130234650774.png" alt="image-20221130234650774"></p></li><li><p>“Duration”告诉计算机作为交换的一部分的附加数据包在无线媒体上需要多长时间。</p><p><img src="/2022/12/29/CNLab4-2/image-20221130234709140.png" alt="image-20221130234709140"></p></li><li><p>“Destination address”和”Source address”（顺序取决于数据帧的具体内容）这些地址字段标识了数据包的发送者和应接收者。</p><p><img src="/2022/12/29/CNLab4-2/image-20221130234849051.png" alt="image-20221130234849051"></p></li><li><p>“BSS Id”是无线接入点的地址。</p><p><img src="/2022/12/29/CNLab4-2/image-20221130234907719.png" alt="image-20221130234907719"></p></li><li><p>“Fragment number”和”Sequence number”这些字段为重组和重传的帧编号，序号随着每一次新的传输而递增。</p><p><img src="/2022/12/29/CNLab4-2/image-20221130234929032.png" alt="image-20221130234929032"></p></li><li><p>“Frame check sequence”是帧上的循环冗余校验码。</p><p><img src="/2022/12/29/CNLab4-2/image-20221130234939063.png" alt="image-20221130234939063"></p></li><li><p>在帧有效负载被加密的情况下，还可能有一个WEP或WPA2字段，其中包含安全参数。</p><p><img src="/2022/12/29/CNLab4-2/image-20221130234948154.png" alt="image-20221130234948154"></p></li></ul><p>最后，我们再重点探究一下”Frame Control”字段的详细内容。</p><p><img src="/2022/12/29/CNLab4-2/image-20221130235557521.png" alt="image-20221130235557521"></p><ul><li>“Version”是版本号，目前为0（三种类型的帧统一，均为0）。</li><li>“Type”和”Subtype”指定帧的类型。</li><li>“DS status”中包含了”To DS”和”From DS”的值：如果帧从计算机通过AP发送至有线网络，则将”To DS”置为1；如果帧从有线网络通过AP发送至计算机，则将”From DS”置为1。</li><li>“More Fragments”描述了消息中是否有更多的帧。</li><li>“Retry”描述了帧是否重传。</li><li>“PWR MGT”意为”Power management”，设置了发送方在传输后是否进入省电休眠状态。</li><li>“More Data”描述发送端是否有更多的帧要发送。</li><li>“Protected”描述了帧是否用WEP&#x2F;WPA2加密。</li><li>“+HTC&#x2F;Order”描述了接收端是否必须保持帧的顺序。</li></ul><h5 id="Step-3-802-11-Physical-Layer"><a href="#Step-3-802-11-Physical-Layer" class="headerlink" title="Step 3: 802.11 Physical Layer"></a>Step 3: 802.11 Physical Layer</h5><p>现在我们已经对802.11数据帧有了一些了解，接下来我们将从物理层开始研究无线系统的其他部分。在最低层，发送和接收消息都与接收信号的频带、调制、信噪比有关，我们可以在Radiotap中的信息查看所有这些元素。</p><p><em>Q: What is the channel frequency?</em></p><p><em>A：展开”Radiotap Header”，即可查看”Channel frequency”的值。</em></p><p><img src="/2022/12/29/CNLab4-2/image-20221201004342137.png" alt="image-20221201004342137"></p><p>要查看调制，我们可以观察数据速率值，要查看信噪比，我们可以观察SSI信号值，SSI信号值通常被称为RSSI(接收信号强度指示)。要查看这些字段，首先必须向主显示添加新列，步骤如下：</p><ol><li><p>按”编辑-首选项-外观-列“的顺序依次点击以进入列显示定义面板。</p></li><li><p>点击左下角”+”以添加新的显示列。</p></li><li><p>将”Title”修改为”RSSI”，类型选择”IEEE 802.11 RSSI”。</p></li><li><p>再添加一个新的显示列，将”Title”修改为”Rate”，类型选择”IEEE 802.11 TX rate”，然后选择”OK”完成添加。</p><p><img src="/2022/12/29/CNLab4-2/image-20221201005949990.png" alt="image-20221201005949990"></p></li></ol><p>我们返回主页面，可以看到”RSSI”列和”Rate”列已成功添加。</p><p><img src="/2022/12/29/CNLab4-2/image-20221201011138673.png" alt="image-20221201011138673"></p><p>在”Rate”列，我们可以看到各种各样的速率。也就是说，与有线以太网的帧以固定速率发送(经过以太网类型的协商)不同，无线速率根据计算机的条件和能力而变化。</p><p><em>Q: What rates are used? Give an ordered list of rates from lowest to highest.</em></p><p><em>A：点击”Rate”列，将帧按速率值从小到大的顺序进行排列，可以看到速率分别为1、6、12、18、24、38、48和54mbps，下面截取了部分速率区段。</em></p><p><img src="/2022/12/29/CNLab4-2/image-20221201012040044.png" alt="image-20221201012040044"></p><p><img src="/2022/12/29/CNLab4-2/image-20221201012115175.png" alt="image-20221201012115175"></p><p><img src="/2022/12/29/CNLab4-2/image-20221201012021756.png" alt="image-20221201012021756"></p><p>在”RSSI”列，我们可以看到各种各样的RSSI值，如“-60 dBm”。RSSI是在对数刻度上测量的，其中0 dBm表示1兆瓦的功率，每+10表示大10倍，每-10表示小10倍。因此-60 dBm意味着 $10^{-9}$ 瓦，即1兆瓦的百万分之一，是非常小的功率。</p><p>信噪比是相对于噪声水平的信号水平，如下图中，信号水平为-60 dBm，噪声水平为-90 dBm，这意味着信号水平比噪声水平大1000倍，那么信噪比就为30 dB。</p><p><img src="/2022/12/29/CNLab4-2/image-20221201013239069.png" alt="image-20221201013239069"></p><p><em>Q: What is the range of RSSI and hence variation in SNRs in the trace? Give this as the strongest and  weakest RSSI and the dB difference between them.</em></p><p><em>A：点击”RSSI”列，将帧按RSSI值从小到大的顺序进行排列，可以看到RSSI的变化范围为-44 dBm（最强信号）到-69 dBm（最弱信号），中间相差了25分贝，前后信噪比之比约为316（$10^{2.5}≈316$）。</em></p><p><img src="/2022/12/29/CNLab4-2/image-20221201014512601.png" alt="image-20221201014512601"></p><p><img src="/2022/12/29/CNLab4-2/image-20221201014524273.png" alt="image-20221201014524273"></p><h5 id="Step-4-802-11-Link-Layer"><a href="#Step-4-802-11-Link-Layer" class="headerlink" title="Step 4: 802.11 Link Layer"></a>Step 4: 802.11 Link Layer</h5><p>在”统计”菜单下，选择”会话”，然后勾选”IEEE 802.11”。</p><p><img src="/2022/12/29/CNLab4-2/image-20221201214202951.png" alt="image-20221201214202951"></p><p>转到”IEEE 802.11”栏，我们将看到如下图所示的窗口，其中列出了每对正在通信的计算机。</p><p><img src="/2022/12/29/CNLab4-2/image-20221201214411420.png" alt="image-20221201214411420"></p><p>大部分的活动都是在相对较小的部分对话中。低活动会话是由于来自空闲计算机的后台流量，以及偶尔从相邻无线网络捕获的少量包。BSS ID值标识一个AP。</p><p><em>Q: What is the BSS ID used by the most active wireless conversations? A BSS ID value identifies an  AP, so this BSS ID identifies the most active AP, presumably the AP we are monitoring.</em> </p><p><em>A：为了找到最活跃的无线会话使用的BSS ID，我们可以通过单击列标题对信息进行排序，可以发现，最活跃的AP的BSS ID是00:16:b6:e3:e9:8f。</em></p><p><img src="/2022/12/29/CNLab4-2/image-20221201215503765.png" alt="image-20221201215503765"></p><p>我们可以在”应用显示过滤器”处输入表达式”wlan.fc.type=&#x3D;”data frame””或”wlan.fc.type=&#x3D;2”来只查看数据帧。</p><p><img src="/2022/12/29/CNLab4-2/image-20221201220113563.png" alt="image-20221201220113563"></p><p><em>Q: How many Data frames are in the trace, and what is the most common subtype of Data frame?</em></p><p><em>A：我们可以从右下角看到当前显示帧的总数为1783，而当前显示的帧正是我们筛选得到的数据帧，所以数据帧的总数为1783。依次查看各帧的详细信息可以发现，数据帧最常见的子类型是”Data”。</em></p><p><img src="/2022/12/29/CNLab4-2/image-20221201221004626.png" alt="image-20221201221004626"></p><p>通过更改筛选表达式来对Control (Type 1)和Management (Type 0)帧执行相同的操作。</p><p><em>Q: How many Control frames are in the trace, and what is the most common subtype?</em> </p><p><em>A：用跟之前同样的方法，我们可以得到控制帧的总数为1391。依次查看各帧的详细信息可以发现，控制帧最常见的子类型是”Acknowledgement”。</em></p><p><img src="/2022/12/29/CNLab4-2/image-20221201221930338.png" alt="image-20221201221930338"></p><p><em>Q: How many Management frames are in the trace, and what is the most common subtype?</em></p><p><em>A：同理，我们也可以得到管理帧的总数为557。依次查看各帧的详细信息可以发现，管理帧最常见的子类型是”Beacon frame”。</em></p><p><img src="/2022/12/29/CNLab4-2/image-20221201222144297.png" alt="image-20221201222144297"></p><p><em>Q: List in the order they are sent the IEEE 802.11 fields in an Acknowledgement frame and their  lengths in bytes. Do not break down the Frame Control field into subfields, as we have already  looked at these details.</em></p><p><em>A：如果我们检查一个”Acknowledgement”帧的IEEE 802.11记录，我们应该看到它与数据帧相比字段很少，例如，只有一个地址，而且它非常短。这些字段分别是帧控制(2个字节)、持续时间(2个字节)、接收地址(6个字节)和帧检查序列(4个字节)。</em></p><p><img src="/2022/12/29/CNLab4-2/image-20221201222740747.png" alt="image-20221201222740747"></p><p>无线传输不像有线传输那样高度可靠，但无线误差率不会很大，否则会浪费大量的介质。我们可以通过估计重传率或检查有多少帧的重试位设置在了帧控制字段（这个位表示一个帧是原始帧的重传）来估算无线误差率。</p><p>我们可以通过使用过滤器表达式来查找原始数据帧和重传数据帧的数量。例如，“wlan.fc.type =&#x3D;2 &amp;&amp; wlan.fc.retry&#x3D;&#x3D;0”将找到原始数据帧。</p><p><em>Q: Give an estimate of the retransmission rate as the number of retransmissions over the number of  original transmissions. Show your calculation.</em></p><p><em>A：在应用显示过滤器处输入“wlan.fc.type =&#x3D;2 &amp;&amp; wlan.fc.retry&#x3D;&#x3D;0”来筛选原始数据帧，可以发现其个数为1430；输入“wlan.fc.type =&#x3D;2 &amp;&amp; wlan.fc.retry=&#x3D;1”来筛选重传数据帧，可以发现其个数为353。由此可以估计重传率为24.69%（353&#x2F;1430≈0.24685）。</em></p><p><img src="/2022/12/29/CNLab4-2/image-20221201223909438.png" alt="image-20221201223909438"></p><p><img src="/2022/12/29/CNLab4-2/image-20221201223955873.png" alt="image-20221201223955873"></p><p>最后，我们将研究电源管理。越来越多的802.11客户端设备在完成发送或接收流量时使用电源管理功能进入低功耗休眠模式。准备休眠的客户端会在帧控制字段中设置电源管理标志，我们可以使用过滤器表达式”wlan.fc.pwrmgt=&#x3D;1”来搜索表明客户端将要休眠的帧。我们只需要考虑从客户端到AP的帧的省电行为，因为来自AP的帧并不表示客户端将进入睡眠状态，这些帧将有”to DS”标志设置(“wlan.fc.tods&#x3D;&#x3D;1”)。要搜索这两个条件，可以使用“&amp;&amp;”或“and”组合筛选器表达式。</p><p><em>Q: What fraction of the frames sent to the AP signal that the client is powering down?</em></p><p><em>A：依次用”wlan.fc.tods=&#x3D;1”和”wlan.fc.pwrmgt=&#x3D;1 and wlan.fc.tods&#x3D;&#x3D;1”筛选后可以发现，发送到AP的帧共822个，其中有16帧设置了电源管理标志，比例约为1.95％(16&#x2F;822≈0.01946)。</em></p><p><img src="/2022/12/29/CNLab4-2/image-20221201225156607.png" alt="image-20221201225156607"></p><p><img src="/2022/12/29/CNLab4-2/image-20221201224940792.png" alt="image-20221201224940792"></p><h5 id="Step-5-802-11-Management"><a href="#Step-5-802-11-Management" class="headerlink" title="Step 5: 802.11 Management"></a>Step 5: 802.11 Management</h5><p>接下来，我们将研究几种类型的管理帧。</p><h6 id="Beacon-Frames"><a href="#Beacon-Frames" class="headerlink" title="Beacon Frames"></a>Beacon Frames</h6><p>选择BSS ID为Step 4中的主AP的”Beacon Frame”。我们将看到，在一些固定的参数之后，它有一系列带标记的参数，这些参数列出了AP的功能。这些参数包括AP的SSID名称(与BSS ID相匹配的文本字符串)、它支持的数据速率以及它所运行的通道。</p><p><em>Q: What is the SSID of the main AP? This is one of the tagged parameters in the Beacon frame.</em></p><p><em>A：如下图，主AP的SSID为“djw”。</em></p><p><img src="/2022/12/29/CNLab4-2/image-20221201231341794.png" alt="image-20221201231341794"></p><p><em>Q: How often are Beacon frames sent for the main AP? You may find the Beacon interval given in the Beacon frame itself, or change the Time display to be show the interval since the last frame.  (Under View, select Time Display Format, and “Seconds Since Previous Displayed Packet”.)</em></p><p><em>A：如图，时间间隔为0.1024秒，约为10次&#x2F;秒。</em></p><p><img src="/2022/12/29/CNLab4-2/image-20221201231717657.png" alt="image-20221201231717657"></p><p><em>Q: What data rates does the main AP support? The rates are listed under tagged parameters.</em></p><p><em>A：如图，支持的速率为1、2、5.5、6、9、11、12、18、24、36、48、54 Mbps（其中，1、2、5.5、11Mbps速率标记为“B”，这意味着它们是802.11b遗留速率而不是802.11g速率）。</em></p><p><img src="/2022/12/29/CNLab4-2/image-20221201232115714.png" alt="image-20221201232115714"></p><p><em>Q: What rate is the Beacon frame transmission? The answer to this question will be found on the  Radiotap header, or more conveniently displayed in the column you added in an earlier step.</em></p><p><em>A：可以从Radiotap报头中找到”Beacon frame”传输速率，如下图，为1.0 Mb&#x2F;s。</em></p><p><img src="/2022/12/29/CNLab4-2/image-20221201232405366.png" alt="image-20221201232405366"></p><h6 id="Association"><a href="#Association" class="headerlink" title="Association"></a>Association</h6><p>一旦计算机通过信标或其他方式了解到AP，它必须与AP关联，并可能在使用无线网络之前对自己进行身份验证。我们将看到计算机向AP发送关联请求，直到它得到确认。如果关联成功，那么AP将返回一个关联响应，计算机将确认该响应。</p><p><em>Q: What are the Type and Subtype values of Association Request &#x2F; Association Response frames?</em></p><p><em>A：依次查看类型为”Association …”的管理帧，可以得到关联请求&#x2F;关联响应帧的类型和子类型值分别为0x0000和0x0001。</em></p><p><img src="/2022/12/29/CNLab4-2/image-20221201233301043.png" alt="image-20221201233301043"></p><p><img src="/2022/12/29/CNLab4-2/image-20221201233344648.png" alt="image-20221201233344648"></p><h6 id="Probe-Request-x2F-Response"><a href="#Probe-Request-x2F-Response" class="headerlink" title="Probe Request&#x2F;Response"></a>Probe Request&#x2F;Response</h6><p>最后，我们来简要了解探测帧。计算机可以探测特定的AP，而不是等待从信标处了解AP。探测请求(Probe Request)由计算机发送，用于测试具有特定SSID的AP是否在附近。如果被寻找的AP在附近，那么它将用探测响应进行回复。对于计算机来说，发送探测请求的无线网络是很常见的，它们以前用来加快连接到已知网络的速度。</p><p><em>Q: What are the Type and Subtype values for the Probe Request &#x2F; Probe Response frames?</em></p><p><em>A：依次查看类型为”Probe …”的管理帧，可以得到关联请求&#x2F;关联响应帧的类型和子类型值分别为0x0004和0x0005。</em></p><p><img src="/2022/12/29/CNLab4-2/image-20221201233856165.png" alt="image-20221201233856165"></p><p><img src="/2022/12/29/CNLab4-2/image-20221201233925568.png" alt="image-20221201233925568"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lab4-1 Wireshark-ethernet</title>
      <link href="/2022/12/29/CNLab4-1/"/>
      <url>/2022/12/29/CNLab4-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Lab4-1-Ethernet"><a href="#Lab4-1-Ethernet" class="headerlink" title="Lab4-1 Ethernet"></a>Lab4-1 Ethernet</h2><h4 id="1-Objective"><a href="#1-Objective" class="headerlink" title="1 Objective"></a>1 Objective</h4><p>了解以太网帧的详细信息。</p><h4 id="2-Requirements"><a href="#2-Requirements" class="headerlink" title="2 Requirements"></a>2 Requirements</h4><p>除Wireshark外，本实验要求能使用ping命令。</p><h4 id="3-Steps"><a href="#3-Steps" class="headerlink" title="3 Steps"></a>3 Steps</h4><h5 id="Step-1-Capture-a-Trace"><a href="#Step-1-Capture-a-Trace" class="headerlink" title="Step 1: Capture a Trace"></a>Step 1: Capture a Trace</h5><ol><li><p>选择一个远程web服务器或其他公共可达的Internet主机，使用ping发送一些ping消息，并检查它是否发送应答。如下图，这里选择了“ping <a href="http://www.baidu.com”./">www.baidu.com”。</a></p><p><img src="/2022/12/29/CNLab4-1/image-20221129103913595.png" alt="image-20221129103913595"></p></li><li><p>启动Wireshark，用”icmp“过滤器开始抓包，并在选项窗口里勾选”Resolve MAC address“，这样可以转换以太网(MAC)地址以提供供应商信息。取消勾选“混杂”，混杂模式对于在广播网络上窃听发送到&#x2F;来自其他计算机的数据包时很有用，但在本实验中我们只想记录发送到&#x2F;从本计算机发出的数据包。</p><p><img src="/2022/12/29/CNLab4-1/image-20221129114019893.png" alt="image-20221129114019893"></p><p><img src="/2022/12/29/CNLab4-1/image-20221129114030347.png" alt="image-20221129114030347"></p></li><li><p>抓包开始后，重复上面的ping命令，这样数据包就会被Wireshark记录下来。</p></li><li><p>待ping命令执行完成后，返回Wireshark并停止抓包，得到的结果如下图。</p><p><img src="/2022/12/29/CNLab4-1/image-20221129114503631.png" alt="image-20221129114503631"></p></li></ol><h5 id="Step-2-Inspect-the-Trace"><a href="#Step-2-Inspect-the-Trace" class="headerlink" title="Step 2: Inspect the Trace"></a>Step 2: Inspect the Trace</h5><p>选中数据包并查看其结构的详细信息和组成包的字节，如下图，可以看到开了MAC地址解析后，在MAC的源地址和目的地址都有一层解析。</p><p><img src="/2022/12/29/CNLab4-1/image-20221129114716848.png" alt="image-20221129114716848"></p><h5 id="Step-3-Ethernet-Frame-Structure"><a href="#Step-3-Ethernet-Frame-Structure" class="headerlink" title="Step 3: Ethernet Frame Structure"></a>Step 3: Ethernet Frame Structure</h5><p><em>To show your understanding of the Ethernet frame format, draw a figure of the ping message that shows the position and size in bytes of the Ethernet header fields.</em></p><table><thead><tr><th>Preamble</th><th>SFD</th><th>Destination Address</th><th>Source Address</th><th>Length&#x2F;Type</th><th>DATA</th><th>Frame Check Sequence</th></tr></thead><tbody><tr><td>7 Byte</td><td>1 Byte</td><td>6 Byte</td><td>6 Byte</td><td>2 Byte</td><td>46~1500 Byte</td><td>4 Byte</td></tr></tbody></table><h5 id="Step-4-Scope-of-Ethernet-Addresses"><a href="#Step-4-Scope-of-Ethernet-Addresses" class="headerlink" title="Step 4: Scope of Ethernet Addresses"></a>Step 4: Scope of Ethernet Addresses</h5><p>每个以太网帧都携带一个源地址和目的地址，其中一个地址就是本地电脑地址。它是发送帧的源，接收帧的目的地，那么另一个地址是什么？当我们 ping 一个远程Internet服务器的时候，我们输入的是域名，经过DNS解析后得到IP地址，我们与目的服务器必然不是直接链接的关系，这中间发生了什么呢？</p><p><em>Draw a figure that shows the relative positions of your computer, the router, and the remote server. Label your computer and the router with their Ethernet addresses. Label your computer and the remote  server with their IP addresses. Show where the Ethernet and the rest of the Internet fit on the drawing.</em></p><p><img src="/2022/12/29/CNLab4-1/image-20221130172601068.png" alt="image-20221130172601068"></p><p><img src="/2022/12/29/CNLab4-1/image-20221130205448670.png" alt="image-20221130205448670"></p><h5 id="Step-5-Broadcast-Frames"><a href="#Step-5-Broadcast-Frames" class="headerlink" title="Step 5: Broadcast Frames"></a>Step 5: Broadcast Frames</h5><p>接下来的部分，可以直接用附件里的”trace-ethernet.pcap”来进行探究。</p><p><em>1. What is the broadcast Ethernet address, written in standard form as Wireshark displays it?</em></p><p>如图可知，地址为 FF:FF:FF:FF:FF:FF 。</p><p><img src="/2022/12/29/CNLab4-1/image-20221130210423289.png" alt="image-20221130210423289"></p><p><em>2. Which bit of the Ethernet address is used to determine whether it is unicast or multicast&#x2F;broadcast?</em></p><p>第8个bit（第一个字节的最低位）。</p><p>如果该位为0，则是某台设备的MAC地址，即单播地址；如果该位为1，则是多播地址（组播+广播&#x3D;多播）。</p><p><img src="/2022/12/29/CNLab4-1/image-20221130211047548.png" alt="image-20221130211047548"></p><h4 id="4-Explore-on-your-own-IEEE-802-3"><a href="#4-Explore-on-your-own-IEEE-802-3" class="headerlink" title="4 Explore on your own (IEEE 802.3)"></a>4 Explore on your own (IEEE 802.3)</h4><p><em>1. How long are the combined IEEE 802.3 and LLC headers compared to the DIX Ethernet headers? You can use Wireshark to work this out. Note that the Trailer&#x2F;Padding and Checksum may be  shown as part of the header, but they come at the end of the frame.</em></p><p>IEEE 802.3与DIX Ethernet一样，报头长度为14 bytes。LLC加入了3 bytes的长度，总长度为17 bytes。</p><p><img src="/2022/12/29/CNLab4-1/image-20221130211741035.png" alt="image-20221130211741035"></p><p><img src="/2022/12/29/CNLab4-1/image-20221130211758296.png" alt="image-20221130211758296"></p><p><em>2. How does the receiving computer know whether the frame is DIX Ethernet or IEEE 802.3? Hint:  you may need to both use Wireshark to look at packet examples and read your text near where the Ethernet formats are described.</em> </p><p>“DIX Ethernet Type”字段和“IEEE 802.3 Length”字段的位置相同。如果该值小于Ox600(1536)，则将其解释为Length值。如果该值大于Ox600(1536)，则将其解释为Type值。</p><p><em>3. If IEEE 802.3 has no Type field, then how is the next higher layer determined? Use Wireshark to  look for the demultiplexing key.</em></p><p>IEEE 802.3在IEEE 802.3报头之后立即添加LLC报头，以传递下一层协议，这从上面的两张图中也能看出来。</p><p>p.s. LLC使用一个称为DSAP的初始字节，而不是Type字段中的两个字节。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lab1-2 Wireshark-protocal layers</title>
      <link href="/2022/12/29/CNLab1-2/"/>
      <url>/2022/12/29/CNLab1-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Lab1-2-Protocol-Layers"><a href="#Lab1-2-Protocol-Layers" class="headerlink" title="Lab1-2 Protocol Layers"></a>Lab1-2 Protocol Layers</h2><h4 id="1-Objective"><a href="#1-Objective" class="headerlink" title="1 Objective"></a>1 Objective</h4><p>了解如何在数据包中表示协议和分层。</p><h4 id="2-Requirements"><a href="#2-Requirements" class="headerlink" title="2 Requirements"></a>2 Requirements</h4><p>实验指导书中该部分分为Wireshark软件安装和wget（或curl）安装，Wireshark安装之前已经记录过了，这里就只写wget的获取了。</p><h5 id="2-1-下载安装wget"><a href="#2-1-下载安装wget" class="headerlink" title="2.1 下载安装wget"></a>2.1 下载安装wget</h5><p>前往<a href="https://eternallybored.org/misc/wget/">GNU Wget 1.21.3 for Windows (eternallybored.org)</a>下载wget，这里选择了1.21.3–64bit–ZIP。</p><h5 id="2-2-配置环境变量"><a href="#2-2-配置环境变量" class="headerlink" title="2.2 配置环境变量"></a>2.2 配置环境变量</h5><p>将文件解压到的路径添加至环境变量。</p><h5 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h5><p>若成功显示wget版本即说明安装成功。</p><p><img src="/2022/12/29/CNLab1-2/image-20221128221711788.png" alt="image-20221128221711788"></p><h4 id="3-Steps"><a href="#3-Steps" class="headerlink" title="3 Steps"></a>3 Steps</h4><h5 id="Step-1-Capture-a-Trace"><a href="#Step-1-Capture-a-Trace" class="headerlink" title="Step 1: Capture a Trace"></a>Step 1: Capture a Trace</h5><ol><li><p>使用wget获取输入的URL的资源，如果状态代码为”200 OK“则说明获取成功，如下图。</p><p><img src="/2022/12/29/CNLab1-2/image-20221129034710216.png" alt="image-20221129034710216"></p></li><li><p>关闭不必要的浏览器选项卡和窗口，通过最小化浏览器活动来阻止计算机获取不必要的web内容，避免在追踪过程中的偶然的流量。</p></li><li><p>启动Wireshark，用”tcp port 80“过滤器开始抓包，并在选项窗口里勾选”Resolve network names“。这个过滤器将只记录标准的网络流量，而不记录计算机可能发送的其他类型的包。勾选的作用是将把发送和接收数据包的计算机的地址转换为名称，这将帮助我们识别数据包是发送到计算机的还是计算机发送出去的。</p><p><img src="/2022/12/29/CNLab1-2/image-20221128223758803.png" alt="image-20221128223758803"></p><p><img src="/2022/12/29/CNLab1-2/image-20221128223906894.png" alt="image-20221128223906894"></p></li><li><p>抓包开始时，使用wget重复web获取，这次的报文就会在传输过程中会被Wireshark记录下来。</p></li><li><p>获取成功后，返回Wireshark并停止抓包。如果成功了的话，Wireshark窗口将显示多个包。捕获的包的个数取决于web页面的大小，通常为20到100个，至少有8个。如下图，本次共抓取了11个（正常包有8个）。</p><p><img src="/2022/12/29/CNLab1-2/image-20221129034513536.png" alt="image-20221129034513536"></p></li></ol><h5 id="Step-2-Inspect-the-Trace"><a href="#Step-2-Inspect-the-Trace" class="headerlink" title="Step 2: Inspect the Trace"></a>Step 2: Inspect the Trace</h5><p>我们可以选中一个数据包来查看它的协议层。这里我们选择一个”Protocol“（协议）列为”HTTP“且”Info“（信息）列为”GET“开头的数据包，可以看到共四层协议，分别为以太网、IP(IPv4)、TCP和HTTP。</p><p><img src="/2022/12/29/CNLab1-2/image-20221129034647595.png" alt="image-20221129034647595"></p><p>注意，顺序是从协议栈的底部向上的。这是因为当数据包沿着堆栈向下传递时，底层协议的头信息被添加到来自上层协议的信息前面。也就是说，下层协议在“线上”数据包中首先出现。</p><p>接下来找到对应从服务器到本机的响应的另一个”HTTP“数据包，这个包的Info字段中应该有“200 OK”，表示获取成功。与HTTP GET包对比，可以看到其有两个额外的部分，如下图所示。</p><p><img src="/2022/12/29/CNLab1-2/image-20221129034803774.png" alt="image-20221129034803774"></p><p>第一个额外的部分写着“[2 Reassembled TCP Segments (2497 bytes): #6(1452), #7(1045)]”，它是关于如何将从服务器发往本机的数据包按顺序组合起来的（因为web响应是通过发送一系列数据包到计算机来实现的，标记为HTTP的数据包是web响应的最后一个数据包）。虽然这些数据包携带着部分HTTP相应，但当前他们每一个都显示有”TCP“。只有最后的包显示为具有HTTP协议时，它们才被组合成一个完整的 HTTP 响应。</p><p>第二个额外的部分写着”Line-based text data: text&#x2F;html (2 lines)“，它描述的是所获取的网页的内容。这不是一个真正的协议，它是Wireshark正在生成的包内容的描述，以帮助我们理解网络流量。</p><h5 id="Step-3-Packet-Structure"><a href="#Step-3-Packet-Structure" class="headerlink" title="Step 3: Packet Structure"></a>Step 3: Packet Structure</h5><p><em>To show your understanding of packet structure, draw a figure of an HTTP GET packet that shows the  position and size in bytes of the TCP, IP and Ethernet protocol headers.</em></p><table><thead><tr><th>Ethernet</th><th>IP</th><th>TCP</th><th>HTTP</th></tr></thead><tbody><tr><td>14B</td><td>20B</td><td>20B</td><td>128B</td></tr><tr><td>Ethernet Header</td><td>Ethernet Payload</td><td>~</td><td>~</td></tr><tr><td></td><td>IP Header</td><td>IP Payload</td><td>~</td></tr><tr><td></td><td></td><td>TCP Header</td><td>TCP Payload</td></tr></tbody></table><p><img src="/2022/12/29/CNLab1-2/image-20221129041434626.png" alt="image-20221129041434626"></p><h5 id="Step-4-Protocol-Overhead"><a href="#Step-4-Protocol-Overhead" class="headerlink" title="Step 4: Protocol Overhead"></a>Step 4: Protocol Overhead</h5><p><em>Estimate the download protocol overhead, or percentage of the download bytes taken up by protocol  overhead. To do this, consider HTTP data (headers and message) to be useful data for the network to  carry, and lower layer headers (TCP, IP, and Ethernet) to be the overhead.</em></p><p>可以通过对Destination列进行排序来只查看下载方向的数据包。数据包应该以一个描述为[SYN ACK]的短TCP包开始，这是连接的开始。接下来，是较大的TCP包（大约1到1.5KB）。最后一个是HTTP包（也可能以一个短的TCP包结束，它是结束连接的一部分）。</p><p><img src="/2022/12/29/CNLab1-2/image-20221129035044873.png" alt="image-20221129035044873"></p><p>对于每个包，我们可以检查它以Ethernet&#x2F;IP&#x2F;TCP报头的形式有多少开销，以及它在TCP有效负载中携带了多少有用的HTTP数据。</p><p>我们依次选中数据包，可以看到下载过程数据总长度为：66 + 56 + 1506 + 1099 &#x3D; 2727 bytes，HTTP数据长度为：1045 bytes，所以下载开销占比为：(2727-1045)&#x2F;2727≈61.7％。</p><p><img src="/2022/12/29/CNLab1-2/image-20221129040200799.png" alt="image-20221129040200799"></p><p>下载协议开销很重要，它保证了数据传输的正确性和可恢复性。因为这里我们的GET请求数据包较短，所以下载协议开销较大。额外的开销部分虽然不是定长，但是基本是在一个较为确定的范围内，只要GET请求的内容包括更多的信息，只要数据包足够大，额外开销的占比就会趋近于0。</p><h5 id="Step-5-Demultiplexing-Keys"><a href="#Step-5-Demultiplexing-Keys" class="headerlink" title="Step 5: Demultiplexing Keys"></a>Step 5: Demultiplexing Keys</h5><p>解复用（Demultiplexing）：当数据包从交给上层进行处理时，需要找到正确的上层协议，这个过程就叫做解复用。</p><p>解复用键（Demultiplexing Keys）：在协议头中来指明上层协议的信息。</p><p><em>1. Which Ethernet header field is the demultiplexing key that tells it the next higher layer is IP?  What value is used in this field to indicate “IP”?</em></p><p>如图：Type；0x0800。</p><p><img src="/2022/12/29/CNLab1-2/image-20221129041859851.png" alt="image-20221129041859851"></p><p><em>2. Which IP header field is the demultiplexing key that tells it the next higher layer is TCP? What  value is used in this field to indicate “TCP”?</em></p><p>如图：Protocol；0x06。</p><p><img src="/2022/12/29/CNLab1-2/image-20221129041934849.png" alt="image-20221129041934849"></p><h4 id="4-Explore-on-your-own"><a href="#4-Explore-on-your-own" class="headerlink" title="4 Explore on your own"></a>4 Explore on your own</h4><p> <em>Look at a short TCP packet that carries no higher-layer data. To what entity is this packet destined? After all, if it carries no higher-layer data then it does not seem very useful to a higher layer protocol such as HTTP!</em></p><p>下图就是一个不包含更高层数据的TCP数据包。</p><p><img src="/2022/12/29/CNLab1-2/image-20221129042407851.png" alt="image-20221129042407851"></p><p>在TCP协议中，建立连接需要三次握手，结束连接需要4次挥手。这几次的数据传递均是不包括高层协议数据的，目的是为了确保连接建立的稳定和准确。</p><p><em>In a classic layered model, one message from a higher layer has a header appended by the lower  layer and becomes one new message. But this is not always the case. Above, we saw a trace in  which the web response (one HTTP message comprised of an HTTP header and an HTTP payload) was converted into multiple lower layer messages (being multiple TCP packets). Imagine  that you have drawn the packet structure (as in step 2) for the first and last TCP packet carrying  the web response. How will the drawings differ?</em> </p><p>第一个包的首部中，Connection字段的值为：keep-alive，表明后续仍有数据。最后一个包请求头中Connection字段的值为：close，表明传输结束，同时最后一个包中还会包含FIN&#x3D;1来请求关闭连接。</p><p><em>In the classic layered model described above, lower layers append headers to the messages  passed down from higher layers. How will this model change if a lower layer adds encryption?</em> </p><p>加密的目的是为了保密内容，所以加密的类型和加密密钥不能随着加密数据一同发送，而是应该在传输数据前根据加密协议进行协商确定。</p><p><em>In the classic layered model described above, lower layers append headers to the messages  passed down from higher layers. How will this model change if a lower layer adds compression?</em></p><p>压缩的目的是为了节省传输流量，所以压缩的协议可直接在下层协议头中指明，便于接收方解压缩。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lab1-1 Wireshark_Intro_v7.0</title>
      <link href="/2022/12/29/CNLab1-1/"/>
      <url>/2022/12/29/CNLab1-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Lab1-1-Getting-Started"><a href="#Lab1-1-Getting-Started" class="headerlink" title="Lab1-1 Getting Started"></a>Lab1-1 Getting Started</h2><h4 id="1-Getting-Wireshark"><a href="#1-Getting-Wireshark" class="headerlink" title="1 Getting Wireshark"></a>1 Getting Wireshark</h4><p>从 <a href="http://www.wireshark.org/download.html">http://www.wireshark.org/download.html</a> 下载并安装Wireshark。</p><h4 id="2-Running-Wireshark"><a href="#2-Running-Wireshark" class="headerlink" title="2 Running Wireshark"></a>2 Running Wireshark</h4><p>Wireshark初始界面：</p><p><img src="/2022/12/29/CNLab1-1/image-20221127193758653.png" alt="image-20221127193758653"></p><p>双击接口名称即可进入对应接口进行抓包，如进入WLAN接口：</p><p><img src="/2022/12/29/CNLab1-1/image-20221127194333009.png" alt="image-20221127194333009"></p><p>抓包界面可大致分为以下五部分：</p><p><img src="/2022/12/29/CNLab1-1/image-20221127200002502.png" alt="image-20221127200002502"></p><ol><li>命令菜单：常用的是”文件“和”捕获“菜单。“文件”菜单可以保存抓包数据，也可以打开以前的抓包数据文件，还有退出Wireshark应用程序等。“捕获”菜单可以允许我们开始或停止抓包。</li><li>数据包列表窗口：显示每一个捕获包的一行摘要，包括包号、数据包被捕获的时间、数据包的源地址和目的地址、协议类型以及数据包中包含的特定于协议的信息。</li><li>包头详细信息窗口：提供了包列表窗口中选中的包的详细信息。这些详细信息包括以太网帧(假设数据包通过以太网接口发送&#x2F;接收)和包含该数据包的IP数据报的信息。</li><li>数据包内容窗口：以ASCII和十六进制格式显示捕获帧的全部内容。</li><li>包过滤显示区域：可以在其中输入协议名或其他信息，以便过滤包列表窗口(以及包头和包内容窗口)中显示的信息。</li></ol><h4 id="3-Taking-Wireshark-for-a-Test-Run"><a href="#3-Taking-Wireshark-for-a-Test-Run" class="headerlink" title="3 Taking Wireshark for a Test Run"></a>3 Taking Wireshark for a Test Run</h4><p>试运行Wireshark来学习其使用流程。</p><ol><li><p>打开浏览器。</p></li><li><p>打开Wireshark软件。</p></li><li><p>选择“捕获”下拉菜单并选择“选项”，打开”Wireshark·捕获选项“。</p><p><img src="/2022/12/29/CNLab1-1/image-20221127202204806.png" alt="image-20221127202204806"></p></li><li><p>选中要开始抓包的接口，然后点击”开始“。</p></li><li><p>开始抓包之后，选择“抓包”下拉菜单并选择“停止”，可以停止抓包（但是现在先不要停止抓包）。</p></li><li><p>当Wireshark正在运行时，在浏览器中打开：<a href="http://gaia.cs.umass.edu/wireshark-labs/INTRO-wireshark-filel.html%E3%80%82%E4%B8%BA%E4%BA%86%E6%98%BE%E7%A4%BA%E6%AD%A4%E9%A1%B5%E9%9D%A2%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B0%86%E5%9C%A8">http://gaia.cs.umass.edu/wireshark-labs/INTRO-wireshark-filel.html。为了显示此页面，浏览器将在</a> <em>gaia.cs.umass.edu</em> 与HTTP服务器联系，并与服务器交换HTTP消息以下载此页面。包含这些HTTP消息的以太网帧(以及通过以太网适配器的所有其他帧)将被Wireshark捕获。</p></li><li><p>在浏览器显示下面的页面后，点击停止按钮，现在可以在已捕获包列表中看到通过这个网络接口的所有的数据包。</p><p><img src="/2022/12/29/CNLab1-1/image-20221127203421287.png" alt="image-20221127203421287"></p></li><li><p>在应用显示过滤器窗口中输入“http”，然后选择Apply(在输入“http”的右侧)。这将导致在包列表窗口中只显示HTTP消息。</p><p><img src="/2022/12/29/CNLab1-1/image-20221127203915269.png" alt="image-20221127203915269"></p></li><li><p>查看HTTP GET信息。当选择HTTP GET消息时，将在报文报头窗口中显示以太网帧、IP数据报、TCP段和HTTP消息报头信息。</p><p><img src="/2022/12/29/CNLab1-1/image-20221127204445952.png" alt="image-20221127204445952"></p></li><li><p>退出Wireshark。</p></li></ol><h4 id="4-What-to-hand-in（Questions）"><a href="#4-What-to-hand-in（Questions）" class="headerlink" title="4 What to hand in（Questions）"></a>4 What to hand in（Questions）</h4><p><em>1. List 3 different protocols that appear in the protocol column in the unfiltered  packet-listing window in step 7 above.</em></p><p>如下图，OICQ，TCP，UDP。</p><p><img src="/2022/12/29/CNLab1-1/image-20221127204731876.png" alt="image-20221127204731876"></p><p><em>2.  How long did it take from when the HTTP GET message was sent until the HTTP  OK reply was received? (By default, the value of the Time column in the packet-listing window is the amount of time, in seconds, since Wireshark tracing began.  To display the Time field in time-of-day format, select the Wireshark View pull  down menu, then select Time Display Format, then select Time-of-day.)</em></p><p>如下图，约为0.241秒。</p><p><img src="/2022/12/29/CNLab1-1/image-20221127205727136.png" alt="image-20221127205727136"></p><p><em>3. What is the Internet address of the gaia.cs.umass.edu (also known as wwwnet.cs.umass.edu)? What is the Internet address of your computer?</em></p><p>如图，<em>gaia.cs.umass.edu</em> 的地址为128.119.245.12，本机地址为172.25.192.244。</p><p><img src="/2022/12/29/CNLab1-1/image-20221127205827144.png" alt="image-20221127205827144"></p><p><em>4. Print the two HTTP messages (GET and OK) referred to in question 2 above. To do so, select Print from the Wireshark File command menu, and select the “Selected Packet Only” and “Print as displayed” radial buttons, and then click OK.</em></p><p>如果，点击”确定“即可打印。</p><p><img src="/2022/12/29/CNLab1-1/image-20221127210357704.png" alt="image-20221127210357704"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2022/12/29/testblog/"/>
      <url>/2022/12/29/testblog/</url>
      
        <content type="html"><![CDATA[<h4 id="似乎有点晚"><a href="#似乎有点晚" class="headerlink" title="似乎有点晚"></a>似乎有点晚</h4><p>建立一个博客来记录学习生活及平时的心理历程等。</p><p>这里是公式测试</p><p>$a^b$</p><p>这里是图片测试</p><p><img src="/2022/12/29/testblog/f0.jpg" alt="测试图片"></p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> testtag </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
